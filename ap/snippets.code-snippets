{
    "template_bitset": {
        "prefix": "template_bitset",
        "body": [
            "template<typename T, const int B>",
            "class bitset_chan",
            "{",
            "public:",
            "    using T_T = T;",
            "    static_assert(sizeof(T) * 8 == B, \"check block width\");",
            "    static_assert(std::is_same<T, uint64_t>::value, \"modify popcnt(), ctz(), clz()\");",
            "",
            "//static helper",
            "public:",
            "    static inline constexpr bool on(int i, T x) noexcept",
            "    {",
            "        return ((T(1) << i) & x) != 0;",
            "    }",
            "    static inline constexpr T prefix(int i) noexcept",
            "    {",
            "        return (i >= B) ? ~T(0) : ((T(1) << i) - T(1));",
            "    }",
            "    static inline constexpr T suffix(int i) noexcept",
            "    {",
            "        return ~prefix(B - i);",
            "    }",
            "    static inline constexpr T range(int l, int r) noexcept",
            "    {",
            "        return prefix(r) ^ prefix(l - 1);",
            "    }",
            "    static constexpr int popcnt(T x) noexcept",
            "    {",
            "        // return _mm_popcnt_u64(x);",
            "        return __builtin_popcountll(x);",
            "    }",
            "    static constexpr int clz(T x) noexcept",
            "    {",
            "        return __builtin_clzll(x);",
            "    }",
            "    static constexpr int ctz(T x) noexcept",
            "    {",
            "        return __builtin_ctzll(x);",
            "    }",
            "    static inline constexpr int block_id(int i) noexcept",
            "    {",
            "        return i / B;",
            "    }",
            " ",
            "//helper",
            "public:",
            "    inline T submask(int l, int r) const noexcept",
            "    {",
            "        int bx = block_id(l);",
            "        assert(bx == block_id(r));",
            "        return (b[bx] & range(l - bx * B + 1, r - bx * B + 1)); ",
            "    }",
            "    inline void trim() noexcept",
            "    {",
            "        b.back() &= prefix(n % B == 0 ? B : n % B);",
            "    }",
            " ",
            "//main",
            "public:",
            "    int n, m;",
            "    std::vector<T> b;",
            " ",
            "    bitset_chan(int n) : bitset_chan(n, false) {};",
            "    bitset_chan(int n, bool init) : n(n), m((n + B - 1)/B), b(m, init ? ~T(0) : T(0)) ",
            "    {",
            "        trim();",
            "    };",
            " ",
            "    inline void set(int i, bool val) noexcept",
            "    {",
            "        assert(0 <= i and i < n);",
            "        if(val)",
            "            b[i/B] |= (T(1) << (i % B));",
            "        else",
            "            b[i/B] &= ~(T(1) << (i % B));",
            "    }",
            " ",
            "    inline bool get(int i) const noexcept",
            "    {",
            "        assert(0 <= i and i < n);",
            "        return (b[i/B] & (T(1) << (i % B))) != 0;",
            "    }",
            " ",
            "    void reset() noexcept",
            "    {",
            "        std::fill(b.begin(), b.end(), T(0));",
            "    }",
            " ",
            "    //bitwise operations",
            "    void operator &= (const bitset_chan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] &= other.b[i];",
            "        if(m > other.m)",
            "            std::fill(b.begin() + other.m, b.begin() + m, T(0));",
            "        // trim();",
            "    }",
            " ",
            "    void operator |= (const bitset_chan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] |= other.b[i];",
            "        trim();",
            "    }",
            " ",
            "    void operator ^= (const bitset_chan &other)",
            "    {",
            "        for(int i = 0; i < std::min(m, other.m); i ++)",
            "            b[i] ^= other.b[i];",
            "        trim();",
            "    }",
            " ",
            "    void operator <<= (int x)",
            "    {",
            "        if(x == 0)",
            "            return;",
            " ",
            "        if(x >= n)",
            "        {",
            "            reset();",
            "            return;",
            "        }",
            " ",
            "        const int s = x/B, d = x % B, r = B - d;",
            " ",
            "        if(d > 0)",
            "        {",
            "            for(int i = m - 1 - s; i > 0; i --)",
            "                b[i + s] = (b[i] << d) | (b[i - 1] >> r);",
            "            b[s] = b[0] << d;",
            "        }",
            "        else",
            "        {",
            "            for(int i = m - 1 - s; i > 0; i --)",
            "                b[i + s] = b[i];",
            "            b[s] = b[0];",
            "        }",
            " ",
            "        std::fill(b.begin(), b.begin() + s, T(0));",
            " ",
            "        trim();",
            "    }",
            " ",
            "    void operator >>= (int x)",
            "    {",
            "        if(x == 0)",
            "            return;",
            "     ",
            "        if(x >= n)",
            "        {",
            "            reset();",
            "            return;",
            "        }",
            " ",
            "        const int s = x/B, d = x % B, l = B - d;",
            " ",
            "        if(d > 0)",
            "        {",
            "            for(int i = s; i < m - 1; i ++)",
            "                b[i - s] = (b[i] >> d) | (b[i + 1] << l); ",
            "            b[m - 1 - s] = b[m - 1] >> d;",
            "        }",
            "        else",
            "            for(int i = s; i < m; i ++)",
            "                b[i - s] = b[i];",
            " ",
            "        std::fill(b.begin() + m - s, b.end(), T(0));        ",
            " ",
            "        // trim();",
            "    }",
            " ",
            "    bool operator == (const bitset_chan &other)",
            "    {",
            "        return ((n == other.n) and b == other.b); ",
            "    }",
            " ",
            "    bool operator != (const bitset_chan &other)",
            "    {",
            "        return !(*this == other);",
            "    }",
            " ",
            "    //extended",
            "    bitset_chan operator & (const bitset_chan &other)",
            "    {",
            "        bitset_chan result(*this);",
            "        result &= other;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator | (const bitset_chan &other)",
            "    {",
            "        bitset_chan result(*this);",
            "        result |= other;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator ^ (const bitset_chan &other)",
            "    {",
            "        bitset_chan result(*this);",
            "        result ^= other;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator >> (int x)",
            "    {",
            "        bitset_chan result(*this);",
            "        result >>= x;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator << (int x)",
            "    {",
            "        bitset_chan result(*this);",
            "        result <<= x;",
            "        return result;",
            "    }",
            " ",
            "    bitset_chan operator ~()",
            "    {",
            "        bitset_chan result(*this);",
            "        for(auto &v : result)",
            "            v = ~v;",
            "        result.trim();",
            "        return result;",
            "    }",
            " ",
            "    //custom operations",
            "    int count() const noexcept",
            "    {",
            "        return std::accumulate(b.begin(), b.end(), 0, [](int sum, T value) { return sum + popcnt(value); });",
            "    }",
            "     ",
            "    int find_first()",
            "    {",
            "        int pos = -1;",
            "",
            "        for(int bi = 0; bi < m; bi ++)",
            "        {",
            "            if(b[bi] == T(0))",
            "                continue;",
            "            ",
            "            pos = ctz(b[bi]) + bi * B;",
            "            break;",
            "        }",
            "",
            "        return pos;",
            "    }",
            "",
            "    int find_last()",
            "    {",
            "        int pos = -1;",
            "",
            "        for(int bi = m - 1; bi >= 0; bi --)",
            "        {",
            "            if(b[bi] == T(0))",
            "                continue;",
            "            ",
            "            pos = B - clz(b[bi]) - 1 + bi * B;",
            "            break;",
            "        }",
            "",
            "        return pos;",
            "    }",
            "",
            "    void range_process(int l, int r, auto block_brute, auto block_quick)",
            "    {",
            "        assert(0 <= l and l <= r and r < n);",
            " ",
            "        int bl = block_id(l), br = block_id(r);",
            " ",
            "        if(bl == br)",
            "            block_brute(l, r);",
            "        else",
            "        {",
            "            block_brute(l, (bl + 1) * B - 1);",
            "            for(int bi = bl + 1; bi < br; bi ++)",
            "                block_quick(bi);",
            "            block_brute(br * B, r);",
            "        }",
            "    }",
            " ",
            "    void range_set(int l, int r, bool val)",
            "    {",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            int bi = block_id(l);",
            "            T mask = range(l - bi * B + 1, r - bi * B + 1);",
            "            if(val)",
            "                b[bi] |= mask;",
            "            else",
            "                b[bi] &= ~mask;",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            b[bi] = (val ? ~T(0) : T(0));",
            "        };",
            "        range_process(l, r, block_brute, block_quick);",
            "    }",
            " ",
            "    int count(int l, int r)",
            "    {",
            "        int cnt = 0;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            cnt += popcnt(submask(l, r));",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            cnt += popcnt(b[bi]);",
            "        };",
            "        range_process(l, r, block_brute, block_quick);",
            "        return cnt;",
            "    }",
            " ",
            "    int find_first (int l, int r)",
            "    {",
            "        int pos = -1;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            for(int i = l; i <= r and pos == -1; i ++)",
            "                if(get(i))",
            "                    pos = i;    ",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            if(b[bi] == T(0) or pos != -1)",
            "                return;",
            " ",
            "            pos = ctz(b[bi]) + bi * B;",
            "        };",
            " ",
            "        range_process(l, r, block_brute, block_quick);",
            "        return pos;",
            "    }",
            "    ",
            "    int find_last(int l, int r)",
            "    {",
            "        int pos = -1;",
            "        auto block_brute = [&](int l, int r) -> void",
            "        {",
            "            for(int i = l; i <= r; i ++)",
            "                if(get(i))",
            "                    pos = i;    ",
            "        };",
            "        auto block_quick = [&](int bi) -> void",
            "        {",
            "            if(b[bi] == T(0))",
            "                return;",
            " ",
            "            pos = B - clz(b[bi]) - 1 + bi * B;",
            "        };",
            " ",
            "        range_process(l, r, block_brute, block_quick);",
            "        return pos;",
            "    }",
            "",
            "    friend std::ostream &operator<<(std::ostream &os, const bitset_chan &bitset)",
            "    {",
            "        for (int i = bitset.m - 1; i >= 0; --i)",
            "            os << std::bitset<B>(bitset.b[i]);",
            "        os << '\\\\n';",
            "        return os;",
            "    }",
            "};",
            "",
            "using bitset_chan64 = bitset_chan<uint64_t, bit_width(uint64_t())>;"
        ],
        "description": "Snippet for bitset"
    },
    "template_block_decomposition": {
        "prefix": "template_block_decomposition",
        "body": [
            "class element_chan",
            "{",
            "public:",
            "};",
            "class block_chan",
            "{",
            "public:",
            "};",
            "",
            "template<typename E, typename T, const int B>",
            "class block_decomposition_chan",
            "{",
            "public:",
            "    static int ceil_div(int x, int y)",
            "    {",
            "        return (x + y - 1)/y;",
            "    }",
            "    static int block_id(int i)",
            "    {",
            "        return i/B;",
            "    }",
            "    static int lb(int bid)",
            "    {",
            "        return bid * B;",
            "    }",
            "    static int rb(int bid)",
            "    {",
            "        return min(n, (bid + 1) * B - 1);",
            "    }",
            "",
            "public:",
            "    int n;",
            "    vector<E> element;",
            "    vector<T> block;",
            "",
            "    block_decomposition_chan(int n, vector<E> a, vector<T> b) : n(n), element(a), block(b)",
            "    {",
            "    };",
            "",
            "    void process(int l, int r, auto block_brute, auto block_quick)",
            "    {",
            "        assert(1 <= l and l <= r and r <= n);",
            "        int bl = block_id(l), br = block_id(r);",
            "        if(bl == br)",
            "            block_brute(l, r);",
            "        else",
            "        {",
            "            block_brute(l, rb(bl));",
            "            for(int b = bl + 1; b < br; b ++)",
            "                block_quick(b);",
            "            block_brute(lb(br), r);",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for block_decomposition"
    },
    "template_cartesian_tree": {
        "prefix": "template_cartesian_tree",
        "body": [
            "template<typename T, typename C>",
            "vector<vector<int>> cartesian_tree(const vector<T> &p, C c = C())",
            "{",
            "    int n = p.size();",
            "",
            "    vector<int> l(n, -1);",
            "",
            "    vector<int> stk;",
            "    for(int i = n - 1; i >= 0; i --)",
            "    {",
            "        while(!stk.empty() and c(p[i], p[stk.back()]))",
            "            l[stk.back()] = i, stk.pop_back();",
            "        stk.push_back(i);",
            "    }",
            "    stk.clear();",
            "",
            "    vector<int> r(n, n);",
            "    for(int i = 0; i < n; i ++)",
            "    {",
            "        while(!stk.empty() and c(p[i], p[stk.back()]))",
            "            r[stk.back()] = i, stk.pop_back();",
            "        stk.push_back(i);",
            "    }",
            "    stk.clear();",
            "",
            "    vector<vector<int>> adj(n);",
            "    for(int i = 0; i < n; i ++)",
            "    {",
            "        int parent = -1;",
            "        if(l[i] != -1)",
            "            parent = l[i];",
            "        ",
            "        if(r[i] != -1)",
            "            if(parent == -1 or !c(p[parent], p[r[i]]))",
            "                parent = r[i];",
            "        ",
            "        if(parent != -1)",
            "            adj[parent].push_back(i);",
            "    }",
            "",
            "    return adj;",
            "}"
        ],
        "description": "Snippet for cartesian_tree"
    },
    "template_dsu": {
        "prefix": "template_dsu",
        "body": [
            "class dsu_chan",
            "{",
            "    /*",
            "        tc: ",
            "            O(n a(n)) amortized",
            "            O(n log(n)) for rollbackable",
            "",
            "        info:",
            "            par[u] stores leader of u",
            "            siz[u] stores size of component with leader u",
            "",
            "        modify:",
            "            to make rollbackable, we do not make modifications in get() [which makes the get() function O(log(N))] ",
            "            and store change info in unite()",
            "    */",
            "public:",
            "    int n;",
            "    vector<int> par;",
            "    vector<int> siz;",
            "    dsu_chan(int n) : n(n), par(n), siz(n, 1)",
            "    {",
            "        iota(par.begin(), par.end(), 0);",
            "    };",
            "    ",
            "    int get(int x)",
            "    {",
            "        return (par[x] == x ? x : par[x] = get(par[x]));",
            "    }",
            "",
            "    void unite(int x, int y)",
            "    {",
            "        x = get(x), y = get(y);",
            "        if(x == y)",
            "            return;",
            "        if(siz[x] > siz[y]) swap(x, y);",
            "        par[x] = y, siz[y] += siz[x];",
            "    }",
            "",
            "    vector<vector<int>> group()",
            "    {",
            "        vector<vector<int>> g(n);",
            "        for(int u = 0; u < n; u ++)",
            "            g[get(u)].push_back(u);",
            "        return g;",
            "    }",
            "};"
        ],
        "description": "Snippet for dsu"
    },
    "template_fenwick_tree": {
        "prefix": "template_fenwick_tree",
        "body": [
            "class node_chan",
            "{",
            "public:",
            "    int v = 0;",
            "",
            "    inline void operator+=(node_chan &other)",
            "    {",
            "        v += other.v;",
            "    }",
            "    inline bool operator<(node_chan &other)",
            "    {",
            "        return v < other.v;",
            "    }",
            "};",
            "template <typename T>",
            "class fenwick_tree_chan",
            "{",
            "public:",
            "    vector<T> fenw;",
            "    int n;",
            "    int pw;",
            "",
            "    fenwick_tree_chan() : n(0) {}",
            "    fenwick_tree_chan(int n) : n(n)",
            "    {",
            "        fenw.resize(n);",
            "        pw = (n == 0 ? 0 : 1ULL << (63 - __builtin_clzll(unsigned(n))));",
            "    }",
            "",
            "    // a[x] += v;",
            "    void modify(int x, T v)",
            "    {",
            "        assert(0 <= x && x < n);",
            "        while (x < n)",
            "        {",
            "            fenw[x] += v;",
            "            x |= x + 1;",
            "        }",
            "    }",
            "",
            "    /// sum of prefix [0, .. x] ",
            "    T query(int x)",
            "    {",
            "        ++ x;",
            "        assert(0 <= x && x <= n);",
            "        T v{};",
            "        while (x > 0)",
            "        {",
            "            v += fenw[x - 1];",
            "            x &= x - 1;",
            "        }",
            "        return v;",
            "    }",
            "",
            "    // Returns the length of the longest prefix (0 indexed) with sum <= c",
            "    int max_prefix(T c)",
            "    {",
            "        T v{};",
            "        int at = 0;",
            "        for (int len = pw; len > 0; len >>= 1)",
            "        {",
            "            if (at + len <= n)",
            "            {",
            "                auto nv = v;",
            "                nv += fenw[at + len - 1];",
            "                if (!(c < nv))",
            "                {",
            "                    v = nv;",
            "                    at += len;",
            "                }",
            "            }",
            "        }",
            "        assert(0 <= at && at <= n);",
            "        return at;",
            "    }",
            "};"
        ],
        "description": "Snippet for fenwick_tree"
    },
    "template_krt": {
        "prefix": "template_krt",
        "body": [
            "class krt_chan",
            "{",
            "public:",
            "    int n;",
            "",
            "    vector<int> wg;",
            "    vector<vector<int>> krt;",
            "",
            "    krt_chan(int n, vector<array<int, 3>> edge, auto cmp) : n(n), wg(2 * n, -1), krt(2 * n)",
            "    {",
            "        int id = n;",
            "        vector<int> par(2 * n);",
            "        iota(par.begin(), par.end(), 0);",
            "",
            "        auto find = [&](int u, auto &&find) -> int",
            "        {",
            "            return (par[u] == u ? u : par[u] = find(par[u], find));",
            "        };",
            "        auto unite = [&](int u, int v, int w) -> void",
            "        {",
            "            u = find(u, find), v = find(v, find);",
            "            if(u == v)",
            "                return;",
            "            par[u] = par[v] = par[id] = id;",
            "            krt[id] = {u, v};",
            "            wg[id] = w;",
            "            id ++;",
            "        };",
            "",
            "        sort(edge.begin(), edge.end(), cmp);",
            "        for(auto [u, v, w] : edge)",
            "            unite(u, v, w);",
            "    };",
            "};"
        ],
        "description": "Snippet for krt"
    },
    "template_monoid_deque": {
        "prefix": "template_monoid_deque",
        "body": [
            "template<template<typename> typename S, typename T>",
            "class monoid_deque_chan",
            "{",
            "public:",
            "    S<T> l, r, t;",
            "",
            "    int size()",
            "    {",
            "        return l.size() + r.size();",
            "    }",
            "    bool empty()",
            "    {",
            "        return (l.empty() and r.empty());",
            "    }",
            "",
            "    void rebalance()",
            "    {",
            "        bool f = false;",
            "",
            "        if(r.empty())",
            "            f = true, l.rswap(r);",
            "        ",
            "        int sz = r.size() / 2;",
            "        while(sz -- )",
            "            t.push(r.top()), r.pop();",
            "        while(!r.empty())",
            "            l.push(r.top()), r.pop();",
            "        while(!t.empty())",
            "            r.push(t.top()), t.pop();",
            "        ",
            "        if(f)",
            "            l.rswap(r);",
            "    }",
            "",
            "    void push_front(T x)",
            "    {",
            "        l.push(x);",
            "    }",
            "    void push_back(T x)",
            "    {",
            "        r.push(x);",
            "    }",
            "",
            "    void pop_front()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())",
            "            rebalance();",
            "        l.pop();",
            "    }",
            "    void pop_back()",
            "    {",
            "        assert(!empty());",
            "        if(r.empty())",
            "            rebalance();",
            "        r.pop();",
            "    }",
            "",
            "    T sum()",
            "    {",
            "        return l.sum().unite(r.sum());",
            "    }",
            "",
            "    T front()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())   ",
            "            rebalance();",
            "        return l.top();",
            "    }",
            "    ",
            "    T back()",
            "    {",
            "        assert(!empty());",
            "        if(r.empty())",
            "            return l.top(0);",
            "        return r.top();",
            "    }",
            "",
            "    void rswap(monoid_deque_chan &other)",
            "    {",
            "        l.rswap(other.l);",
            "        r.rswap(other.r);",
            "        t.rswap(other.t);",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_deque"
    },
    "template_monoid_queue": {
        "prefix": "template_monoid_queue",
        "body": [
            "template<template<typename> typename S, typename T>",
            "class monoid_queue_chan",
            "{",
            "public:",
            "    S<T> l, r;",
            "",
            "    int size()",
            "    {",
            "        return l.size() + r.size();",
            "    }",
            "",
            "    bool empty()",
            "    {",
            "        return (l.empty() and r.empty());",
            "    }",
            "",
            "    void rebalance()",
            "    {",
            "        while(!r.empty())",
            "            l.push(r.top()), r.pop();",
            "    }",
            "",
            "    void push(T x)",
            "    {",
            "        r.push(x);",
            "    }",
            "",
            "    void pop()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())   rebalance();",
            "        l.pop();",
            "    }",
            "",
            "    T sum()",
            "    {",
            "        return l.sum().unite(r.sum());",
            "    }",
            "",
            "    T front()",
            "    {",
            "        assert(!empty());",
            "        if(l.empty())   rebalance();",
            "        return l.top();",
            "    }",
            "    ",
            "    T back()",
            "    {",
            "        assert(!empty());",
            "        if(r.empty())",
            "            return l.top(0);",
            "        return r.top();",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_queue"
    },
    "template_monoid_stack": {
        "prefix": "template_monoid_stack",
        "body": [
            "template<typename T>",
            "class monoid_stack_chan",
            "{",
            "public:",
            "    vector<pair<T, T>> stk;",
            "    int size()",
            "    {",
            "        return stk.size();",
            "    }",
            "",
            "    bool empty()",
            "    {",
            "        return stk.empty();",
            "    }",
            "",
            "    void push(T x)",
            "    {",
            "        stk.push_back({x, x.unite(sum())});",
            "    }",
            "",
            "    void pop()",
            "    {",
            "        assert(!stk.empty());",
            "        stk.pop_back();",
            "    }",
            "",
            "    T top()",
            "    {",
            "        assert(!stk.empty());",
            "        return stk.back().first;",
            "    }",
            "",
            "    T sum(int i = -1)",
            "    {",
            "        if(i == -1) ",
            "            i = size() - 1;",
            "        if(i == -1)",
            "            return T();",
            "        return stk[i].second;",
            "    }",
            "",
            "    void rswap(monoid_stack_chan &other)",
            "    {",
            "        swap(stk, other.stk);",
            "    }",
            "};"
        ],
        "description": "Snippet for monoid_stack"
    },
    "template_offline_deletion": {
        "prefix": "template_offline_deletion",
        "body": [
            "template<typename T, typename Q, typename D>",
            "class offline_deletion_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<Q> ans;",
            "    vector<vector<T>> store;",
            "    D ds;",
            "",
            "    offline_deletion_chan(int n) : ",
            "    n(n), ans(4 * n + 5), store(4 * n + 5) {};",
            "",
            "    //put(L, R, life) puts element \"life\" into segment [L, R]",
            "    void put(int L, int R, T life)",
            "    {",
            "        auto rec = [&](int v, int l, int r, auto &&rec) -> void",
            "        {",
            "            if(l > r or r < L or R < l)",
            "                return;",
            "",
            "            if(L <= l and r <= R)",
            "            {",
            "                store[v].push_back(life);",
            "                return;",
            "            }",
            "            ",
            "            int mid = (l + r)/2;",
            "            put(v * 2, l, mid, rec);",
            "            put(v * 2 + 1, mid + 1, r, rec);",
            "        };",
            "        rec(1, 1, n, rec);",
            "    }",
            "",
            "    void compute()",
            "    {",
            "        auto dfs = [&](int v, int l, int r, auto &&dfs) -> void",
            "        {",
            "            if(l > r)",
            "                return;",
            "",
            "            for(auto point : store[v])",
            "                ds.Insert(point);",
            "",
            "            if(l == r)",
            "                ans[l] = ds.Query();",
            "            else",
            "            {",
            "                int mid = (l + r)/2;",
            "                dfs(v * 2, l, mid, dfs);",
            "                dfs(v * 2 + 1, mid + 1, r, dfs);",
            "            }",
            "            ",
            "            for(auto point : store[v])",
            "                ds.Rollback();",
            "        };",
            "        dfs(1, 1, n, dfs);",
            "    }",
            "};"
        ],
        "description": "Snippet for offline_deletion"
    },
    "template_sparse_table": {
        "prefix": "template_sparse_table",
        "body": [
            "template <typename T>",
            "class sparse_table_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<vector<T>> mat;",
            "    sparse_table_chan(const vector<T> &a)",
            "    {",
            "        n = a.size();",
            "        int max_log = 32 - __builtin_clz(n);",
            "        mat.resize(max_log);",
            "        mat[0] = a;",
            "        for (int j = 1; j < max_log; j++)",
            "        {",
            "            mat[j].resize(n - (1 << j) + 1);",
            "            for (int i = 0; i <= n - (1 << j); i++)",
            "                mat[j][i] = mat[j - 1][i].unite(mat[j - 1][i + (1 << (j - 1))]);",
            "        }",
            "    }",
            "    T query(int from, int to) const",
            "    {",
            "        assert(0 <= from && from <= to && to <= n - 1);",
            "        int lg = 32 - __builtin_clz(to - from + 1) - 1;",
            "        return mat[lg][from].unite(mat[lg][to - (1 << lg) + 1]);",
            "    }",
            "};"
        ],
        "description": "Snippet for sparse_table"
    },
    "template_bst_node": {
        "prefix": "template_bst_node",
        "body": [
            "class node",
            "{",
            "public:",
            "//tree info",
            "    node *l, *r, *p;",
            "    //self",
            "    int key;",
            "    //subtree aggregate",
            "    int siz;",
            "",
            "//monoid info",
            "    //self",
            "    int64_t val;",
            "",
            "    //subtree Aggregates",
            "    int64_t sum;",
            "",
            "    //lazy propagation",
            "    int64_t add;",
            "",
            "    node()",
            "    {",
            "        p = l = r = nullptr;",
            "        key = siz = val = sum = add = 0;",
            "    }",
            "",
            "    //current attributes are already updated, update child attributes so that a pull would result in the correct aggregate",
            "    void push()",
            "    {",
            "        if(l != nullptr)",
            "            l->sum += add * l->siz, l->val += add, l->add += add;",
            "        if(r != nullptr)",
            "            r->sum += add * r->siz, r->val += add, r->add += add;",
            "        add = 0;",
            "    }",
            "    void pull()",
            "    {",
            "        siz = sum = 0;",
            "        if(l != nullptr)",
            "            siz += l->siz, sum += l->sum;",
            "        siz += 1, sum += val;",
            "        if(r != nullptr)",
            "            siz += r->siz, sum += r->sum;",
            "    }",
            "};"
        ],
        "description": "Snippet for bst_node"
    },
    "template_splay": {
        "prefix": "template_splay",
        "body": [
            "/*",
            "general ideas:",
            "- Can do a dfs to an arbitrary node in O(log(n)) time, if you always splay it afterwards",
            "- For single node modifications, we generally splay the node first and then do what we want",
            "- BST property is maintained throughout (key can be redundant a lot of times)",
            "*/",
            "",
            "namespace splay_chan",
            "{",
            "    //common: push, splay, pull",
            "    bool is_root(node* u)",
            "    {",
            "        if(u == nullptr)",
            "            return false;",
            "        return (u->p == nullptr);",
            "    }",
            "",
            "    void rotate(node* u)",
            "    {",
            "        auto p = u->p;",
            "        assert(p != nullptr);",
            "",
            "        p->push();",
            "        u->push();",
            "",
            "        u->p = p->p;",
            "        p->p = u;",
            "",
            "        if(u->p != nullptr)",
            "        {",
            "            if(u->p->l == p)",
            "                u->p->l = u;",
            "            if(u->p->r == p)",
            "                u->p->r = u;",
            "        }",
            "",
            "        if(u == p->l)",
            "        {",
            "            p->l = u->r;",
            "            if(u->r != nullptr)",
            "                u->r->p = p;",
            "            u->r = p;",
            "        }",
            "        else",
            "        {",
            "            p->r = u->l;",
            "            if(u->l != nullptr)",
            "                u->l->p = p;",
            "            u->l = p;",
            "        }",
            "",
            "        p->pull();",
            "        u->pull();",
            "    }",
            "",
            "    void splay(node *u)",
            "    {",
            "        if(u == nullptr)",
            "            return;",
            "        while(!is_root(u))",
            "        {",
            "            auto p = u->p;",
            "            if(!is_root(p))",
            "            {",
            "                if((p->l == u) ^ (p->p->l == p))",
            "                    rotate(u);",
            "                else",
            "                    rotate(p);",
            "            }",
            "            rotate(u);",
            "        }",
            "    }",
            "",
            "    pair<node*, int> access(node* u, const function<int(node*)> &go_to)",
            "    {",
            "        if(u == nullptr)",
            "            return {u, 0};",
            "        splay(u);",
            "        int d = 0;",
            "",
            "        while(1)",
            "        {",
            "            u->push();",
            "            d = go_to(u);",
            "            if(d == 0)",
            "                break;",
            "            node *v = (d == -1 ? u->l : u->r);",
            "            if(v == nullptr)",
            "                break;",
            "            u = v;      ",
            "        }",
            "",
            "        splay(u);",
            "        return {u, d};",
            "    }",
            "",
            "    node* get_leftmost(node* u)",
            "    {",
            "        return access(u, [&](node*) {return -1;}).first;",
            "    }",
            "",
            "    node* get_rightmost(node* u)",
            "    {",
            "        return access(u, [&](node*) {return 1;}).first;",
            "    }",
            "",
            "    node* get_kth(node* u, int k)        // 0-indexed",
            "    {",
            "        pair<node*, int> p = access(u, [&](node* u)",
            "        {",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz > k)",
            "                    return -1;",
            "                k -= u->l->siz;",
            "            }",
            "            if(k == 0)",
            "                return 0;",
            "            -- k;",
            "            return 1;",
            "        });",
            "",
            "        auto v = p.first;",
            "        v->push();",
            "        splay(v);",
            "",
            "        return (p.second == 0 ? v : nullptr); ",
            "    }",
            "",
            "    int get_position(node *u)        // 0 -indexed",
            "    {",
            "        splay(u);",
            "        return (u->l == nullptr ? 0 : u->l->siz);",
            "    }",
            "",
            "    node* get_root(node* u)",
            "    {",
            "        splay(u);",
            "        return u;",
            "    }",
            "",
            "    pair<node*, node*> split(node* u, const function<bool(node*)> &IsRight)",
            "    {",
            "        if(u == nullptr)",
            "            return {nullptr, nullptr};",
            "        ",
            "        pair<node*, int> p = access(u, [&](node* u) {return IsRight(u) ? -1 : 1;});",
            "        ",
            "        //if p.second == 1, we have found the greatest node which should be in the left subtree",
            "        //if p.second == -1, we have found the smallest node which should be in the right subtree",
            "        //then in both cases, we splayed this node and its now the root",
            "",
            "        u = p.first;",
            "        u->push();",
            "        splay(u);",
            "",
            "        if(p.second == -1)",
            "        {",
            "            node* v = u->l;",
            "            if(v == nullptr)",
            "                return {nullptr, u};",
            "            u->l = nullptr;",
            "            v->p = nullptr;",
            "            u->pull();",
            "            return {v, u};",
            "        }",
            "        else",
            "        {",
            "            node* v = u->r;",
            "            if(v == nullptr)",
            "                return {u, nullptr};",
            "            u->r = nullptr;",
            "            v->p = nullptr;",
            "            u->pull();",
            "            return {u, v};",
            "        }",
            "",
            "        return {nullptr, nullptr};",
            "    }",
            "",
            "    node* merge(node* u, node* v)       //all in u <= all in v",
            "    {",
            "        if(u == nullptr)",
            "            return v;",
            "        if(v == nullptr)",
            "            return u;",
            "        ",
            "        u = get_rightmost(u);",
            "        u->push();",
            "        ",
            "        splay(u);",
            "",
            "        assert(u->r == nullptr);",
            "        u->r = v;",
            "        v->p = u;",
            "        u->pull();",
            "",
            "        return u;",
            "    }",
            "",
            "    node *insert(node *r, node *v, const function<bool(node *)> &go_left)",
            "    {",
            "        //returns new root",
            "        pair<node *, node *> p = split(r, go_left);",
            "        return merge(p.first, merge(v, p.second));",
            "    }",
            "",
            "    node *remove(node *u)",
            "    { ",
            "        // returns the new root",
            "        splay(u);",
            "        u->push();",
            "        node *x = u->l;",
            "        node *y = u->r;",
            "        u->l = u->r = nullptr;",
            "        if(x != nullptr)",
            "            x->p = nullptr;",
            "        if(y != nullptr) ",
            "            y->p = nullptr;",
            "        node *z = merge(x, y);",
            "        ",
            "        u->p = nullptr;",
            "        u->push();",
            "        u->pull(); // now u might be reusable...",
            "        ",
            "        return z;",
            "    }",
            "",
            "    //untested",
            "    node *next(node *v)",
            "    {",
            "        splay(v);",
            "        v->push();",
            "        //find leftmost node in subtree of right child of node v",
            "        if (v->r == nullptr)",
            "            return nullptr;",
            "        v = v->r;",
            "        while (v->l != nullptr)",
            "        {",
            "            v->push();",
            "            v = v->l;",
            "        }",
            "        splay(v);",
            "        return v;",
            "    }",
            "",
            "    //untested",
            "    node *prev(node *v)",
            "    {",
            "        splay(v);",
            "        v->push();",
            "        //find rightmost node in subtree of left child of v",
            "        if (v->l == nullptr)",
            "            return nullptr;",
            "        v = v->l;",
            "        while (v->r != nullptr)",
            "        {",
            "            v->push();",
            "            v = v->r;",
            "        }",
            "        splay(v);",
            "        return v;",
            "    }",
            "",
            "    //0-indexed",
            "    //`operate(0, node*)` is to operate with single node",
            "    //`operate(1, node*)` is to operate on subtree of node",
            "    template<typename O>",
            "    node* query(node* u, int l, int r, O operate)",
            "    {",
            "        u = get_kth(u, l);",
            "        assert(u != nullptr);",
            "        assert(l <= r and r < u->siz);",
            "",
            "        int remaining = (r - l + 1);",
            "        ",
            "        -- remaining;",
            "        operate(0, u);",
            "        u->push();",
            "",
            "        if(u->r != nullptr)",
            "            u = u->r;",
            "",
            "        while(remaining > 0)",
            "        {",
            "            u->push();",
            "",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz >= remaining)",
            "                {",
            "                    u = u->l;",
            "                    continue;",
            "                }",
            "                remaining -= u->l->siz;",
            "                operate(1, u->l);",
            "            }",
            "",
            "            if(remaining > 0)",
            "            {",
            "                -- remaining;",
            "                operate(0, u);",
            "            }",
            "",
            "            if(u->r == nullptr)",
            "                break;",
            "            u = u->r;",
            "        }",
            "",
            "        u->push();",
            "        splay(u);",
            "        u->pull();",
            "",
            "        return u;",
            "    }",
            "",
            "    //0-indexed",
            "    //`operate(0, node*)` is to operate with single node",
            "    //`operate(1, node*)` is to operate on subtree of node",
            "    template<typename O>",
            "    node* modify(node* u, int l, int r, O operate)",
            "    {",
            "        u = get_kth(u, l);",
            "        assert(u != nullptr);",
            "        assert(l <= r and r < u->siz);",
            "",
            "        int remaining = (r - l + 1);",
            "        ",
            "        -- remaining;",
            "        operate(0, u);",
            "        u->push();",
            "",
            "        auto dfs = [&](auto &&dfs) -> void",
            "        {",
            "            if(remaining == 0)",
            "                return;",
            "            ",
            "            node* cur = u;",
            "            u->push();",
            "",
            "            if(u->l != nullptr)",
            "            {",
            "                if(u->l->siz >= remaining)",
            "                {",
            "                    u = u->l;",
            "                    dfs(dfs);",
            "",
            "                    cur->pull();",
            "                    return;",
            "                }",
            "                ",
            "                remaining -= u->l->siz;",
            "                operate(1, u->l);",
            "                u->pull();          //left child might have been updated",
            "            }",
            "",
            "            if(remaining > 0)",
            "            {",
            "                -- remaining;",
            "                operate(0, u);",
            "            }",
            "",
            "            if(u->r == nullptr)",
            "            {",
            "                cur->pull();",
            "                return;",
            "            }",
            "",
            "            u = u->r;",
            "            dfs(dfs);",
            "",
            "            cur->pull();",
            "            return;",
            "        };",
            "",
            "        if(u->r != nullptr)",
            "            u = u->r;",
            "        ",
            "        node* cur = u;",
            "        dfs(dfs);",
            "        cur->pull();",
            "",
            "        u->push();",
            "        splay(u);",
            "        u->pull();",
            "",
            "        return u;",
            "    }",
            "};",
            "using namespace splay_chan;"
        ],
        "description": "Snippet for splay"
    },
    "template_segment": {
        "prefix": "template_segment",
        "body": [
            "struct Node ",
            "{",
            "    int mx,mn,sm;",
            "};",
            "class segtree",
            "{",
            "    public:",
            "    vector<Node>tree;",
            "    vector<int> arr;",
            "    int n;",
            "    void unite(Node &merged, Node &left, Node &right)",
            "    {   ",
            "        merged.mn=min(left.mn,right.mn);",
            "        merged.mx=max(left.mx,right.mx);",
            "        merged.sm=(left.sm+right.sm);",
            "    }",
            "    void build(int idx,int st,int en) ",
            "    {",
            "        if (st==en) tree[idx]={arr[st],arr[st],arr[st]};",
            "        else",
            "        {",
            "            int mid=(st+en)/2;",
            "            build(2*idx+1,st,mid);",
            "            build(2*idx+2,mid+1,en);",
            "            Node left=tree[2*idx+1];",
            "            Node right=tree[2*idx+2];",
            "            unite(tree[idx],left,right);",
            "        }",
            "    }",
            "    Node query(int idx,int st,int en,int l,int r) ",
            "    {",
            "        Node ansNode;",
            "        if (r<st || en<l) ansNode={-inf,inf,0}; ",
            "        else if (l<=st && en<=r) ansNode=tree[idx];",
            "        else",
            "        {",
            "            int mid=(st+en)/2;",
            "            Node left=query(2*idx+1,st,mid,l,r);",
            "            Node right=query(2*idx+2,mid+1,en,l,r);",
            "            unite(ansNode,left,right);",
            "        }",
            "        return ansNode;",
            "    }",
            "    void update(int idx,int st,int en,int pos,int val) ",
            "    {",
            "        if (st==en) tree[idx]={val,val,val},arr[en]=val; ",
            "        else",
            "        {",
            "            int mid=(st+en)/2;",
            "            if (pos<=mid) update(2*idx+1,st,mid,pos,val);",
            "            else update(2*idx+2,mid+1,en,pos,val);",
            "            Node left=(tree[2*idx+1]);",
            "            Node right=tree[2*idx+2];",
            "            unite(tree[idx],left,right);",
            "        }",
            "    }",
            "",
            "    segtree(vector<int> input) // 0 based",
            "    {",
            "        this->arr=input;",
            "        this->n=arr.size();",
            "        this->tree.resize(4*n);",
            "        build(0,0,n-1);",
            "    }",
            "    Node query(int l, int r) // 0 based",
            "    {",
            "        return query(0,0,n-1,l,r);",
            "    }",
            "    void update(int pos,int val) // 0 based",
            "    {",
            "        update(0,0,n-1,pos,val);",
            "    }",
            "};"
        ],
        "description": "Snippet for segment"
    },
    "template_dynamic_monoid": {
        "prefix": "template_dynamic_monoid",
        "body": [
            "class dynamic_monoid_chan",
            "{",
            "public:",
            "    dynamic_monoid_chan *left, *right;",
            "    int sum = 0;",
            "",
            "    dynamic_monoid_chan() : sum(0) {};",
            "    dynamic_monoid_chan(int x) : sum(x) {};",
            "",
            "    dynamic_monoid_chan unite(dynamic_monoid_chan b) const ",
            "    {",
            "        dynamic_monoid_chan res(sum + b.sum);",
            "        return res;",
            "    }",
            "    static dynamic_monoid_chan get_default([[maybe_unused]] int l, [[maybe_unused]] int r)",
            "    {",
            "        return dynamic_monoid_chan();",
            "    }",
            "",
            "    dynamic_monoid_chan grow()",
            "    {",
            "        if(left == nullptr)",
            "        {",
            "            left = new dynamic_monoid_chan();",
            "            right = new dynamic_monoid_chan();",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for dynamic_monoid"
    },
    "template_convex_hull_trick": {
        "prefix": "template_convex_hull_trick",
        "body": [
            "class cht_chan",
            "{",
            "public:",
            "    /*",
            "        tc: O(log(n)) per insertion amortized, O(log(n)) per query",
            "        ml: O(n)",
            "",
            "        info:",
            "            1. inserts lines of form Ax + B",
            "            2. returns inserted line with maximum value of Ax + B for queried x ",
            "    */",
            "\tstatic const int64_t INF=1e18;",
            "\tstruct Line",
            "\t{",
            "\t\tint64_t a, b; //y = ax + b",
            "\t\tdouble xLeft; //Stores the llersection wiith previous line in the convex hull. First line has -INF",
            "",
            "\t\tenum Type {line, maxQuery, minQuery} type;",
            "\t\tint64_t val;",
            "",
            "\t\texplicit Line(int64_t aa=0, int64_t bb=0): a(aa), b(bb), xLeft(-INF), type(Type::line), val(0) {}",
            "",
            "\t\tint64_t valueAt(int64_t x) const",
            "\t\t{",
            "\t\t\treturn a*x + b;",
            "\t\t}",
            "\t\tfriend bool isParallel(const Line &l1, const Line &l2)",
            "\t\t{",
            "\t\t\treturn l1.a == l2.a;",
            "\t\t}",
            "\t\tfriend double llersectX(const Line &l1, const Line &l2)",
            "\t\t{",
            "\t\t\treturn isParallel(l1, l2)?INF:1.0*(l2.b-l1.b)/(l1.a-l2.a);",
            "\t\t}",
            "\t\tbool operator<(const Line& l2) const",
            "\t\t{",
            "\t\t\tif(l2.type == line)",
            "\t\t\t\treturn this->a < l2.a;",
            "\t\t\tif(l2.type == maxQuery)",
            "\t\t\t\treturn this->xLeft < l2.val;",
            "\t\t\tif(l2.type == minQuery)",
            "\t\t\t\treturn this->xLeft > l2.val;",
            "            return 0;",
            "\t\t}",
            "\t};",
            "",
            "\tbool isMax;",
            "\tset<Line> hull;",
            "",
            "\tbool hasPrev(set<Line>::iterator it)",
            "\t{",
            "\t\treturn it!=hull.begin();",
            "\t}\t",
            "\tbool hasNext(set<Line>::iterator it)",
            "\t{",
            "\t\treturn it!=hull.end() && next(it)!=hull.end();",
            "\t}",
            "\tbool irrelevant(const Line &l1, const Line &l2, const Line &l3)",
            "\t{",
            "\t\treturn llersectX(l1, l3) <= llersectX(l1, l2);",
            "\t}",
            "\tbool irrelevant(set<Line>::iterator it)",
            "\t{",
            "\t\treturn hasPrev(it) && hasNext(it) && ( ",
            "\t\t\t(isMax && irrelevant(*prev(it), *it, *next(it))) ",
            "\t\t\t|| (!isMax && irrelevant(*next(it), *it, *prev(it))));",
            "\t}",
            "\t//Updates xValue of line polled by it",
            "\tset<Line>::iterator updateLeftBorder(set<Line>::iterator it)",
            "\t{",
            "\t\tif(isMax && !hasPrev(it) || !isMax && !hasNext(it))",
            "\t\t\treturn it;",
            "\t\tdouble val=llersectX(*it, isMax?(*prev(it)):(*next(it)));",
            "\t\tLine temp(*it);",
            "\t\tit=hull.erase(it);",
            "\t\ttemp.xLeft=val;",
            "\t\tit=hull.insert(it, temp);",
            "\t\treturn it;",
            "\t}",
            "",
            "\texplicit cht_chan(bool isMax): isMax(isMax) {}",
            "",
            "\tvoid add_line(int64_t a, int64_t b) //Add ax + b in logN time",
            "\t{",
            "\t\tLine l3=Line(a, b);",
            "\t\tauto it=hull.lower_bound(l3);",
            "",
            "\t\t//If parallel liune is already in set, one of the lines becomes irrelevant",
            "\t\tif(it!=hull.end() && isParallel(*it, l3))",
            "\t\t{",
            "\t\t\tif(isMax && it->b<b || !isMax && it->b>b)",
            "\t\t\t\tit=hull.erase(it);",
            "\t\t\telse",
            "\t\t\t\treturn;",
            "\t\t}",
            "",
            "\t\tit=hull.insert(it, l3);",
            "\t\tif(irrelevant(it))",
            "\t\t{",
            "\t\t\thull.erase(it);",
            "\t\t\treturn;",
            "\t\t}",
            "",
            "\t\t//Remove lines which became irrelevant after inserting",
            "\t\twhile(hasPrev(it) && irrelevant(prev(it)))",
            "\t\t\thull.erase(prev(it));",
            "\t\twhile(hasNext(it) && irrelevant(next(it)))",
            "\t\t\thull.erase(next(it));",
            "",
            "\t\t//Update xLine",
            "\t\tit=updateLeftBorder(it);",
            "\t\tif(hasPrev(it))",
            "\t\t\tupdateLeftBorder(prev(it));",
            "\t\tif(hasNext(it))",
            "\t\t\tupdateLeftBorder(next(it));",
            "\t}",
            "",
            "\tint64_t get_opt(int64_t x)",
            "\t{",
            "\t\tLine q;",
            "\t\tq.val=x;",
            "\t\tq.type = isMax?Line::Type::maxQuery : Line::Type::minQuery;",
            "",
            "\t\tauto bestLine=hull.lower_bound(q);",
            "\t\tif(isMax)",
            "\t\t\t--bestLine;",
            "\t\treturn bestLine->valueAt(x);",
            "\t}",
            "};"
        ],
        "description": "Snippet for convex_hull_trick"
    },
    "template_connectivity": {
        "prefix": "template_connectivity",
        "body": [
            "class connectivity_chan",
            "{",
            "    /*",
            "        n -> number of nodes",
            "        bridge -> contains all bridges",
            "        a -> number of cutpoints",
            "        cut[u] -> is u an articulation point",
            "        m -> n + number of biconnected components (bcc's indexed in [n, inf))",
            "        bcc -> stores bcc's",
            "        b -> number of nodes in the block cut tree",
            "",
            "        Block: BCC",
            "        All edges form equivalence classes, these are grouped into blocks (BCCs)",
            "        These blocks may share vertices but not edges",
            "        A bipartite graph (and tree), BCT is formed by creating a node for every block, every",
            "        cut-point and adding an edge from every cut-point to all the blocks it is a part of.",
            "    */",
            "public:",
            "    int n;",
            "    vector<vector<int>> adj;",
            "    int timer;",
            "    vector<int> tin, low;",
            "",
            "    vector<pair<int, int>> bridge;",
            "",
            "    int a;",
            "    vector<bool> cut;",
            "",
            "    int m;",
            "    vector<vector<int>> bcc;",
            "",
            "    int b;",
            "    vector<int> block_node_id;",
            "    vector<int> cut_node_id;",
            "    vector<vector<int>> bct_comp;    ",
            "    vector<vector<int>> bct;",
            "",
            "    connectivity_chan(const vector<vector<int>> &adj) : ",
            "    n(adj.size()), m(n), adj(adj), timer(0), tin(n, -1), low(n, -1), cut(n), bcc(n), ",
            "    block_node_id(n, -1), cut_node_id(n, -1) ",
            "    {",
            "        compute_connectivity();",
            "        make_block_cut_tree();",
            "    };",
            "",
            "    void compute_connectivity()",
            "    {",
            "        vector<bool> vis(n);",
            "        vector<int> stk;",
            "",
            "        auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            tin[u] = low[u] = timer ++;",
            "            vis[u] = true;",
            "            stk.push_back(u);",
            "",
            "            int ptimes = 0;",
            "            int children = 0;",
            "            for(auto v : adj[u])",
            "            {",
            "                if(v == p)",
            "                {",
            "                    ++ ptimes;",
            "                    continue;",
            "                }",
            "",
            "                if(vis[v])",
            "                    low[u] = min(low[u], tin[v]);",
            "                else",
            "                {",
            "                    ++ children;",
            "                    int s = stk.size();",
            "                    dfs(v, u, dfs);",
            "                    low[u] = min(low[u], low[v]);",
            "",
            "                    if((p == -1 and children > 1) or (p != -1 and tin[u] <= low[v]))",
            "                    {",
            "                        cut[u] = true;",
            "                        bcc.push_back(vector<int> ());",
            "                        bcc[m].push_back(u);",
            "                        while(stk.size() > s)",
            "                        {",
            "                            bcc[m].push_back(stk.back());",
            "                            stk.pop_back();",
            "                        }",
            "                        ++ m;",
            "                    }",
            "                }",
            "            ",
            "            }",
            "",
            "            if(p != -1 and ptimes <= 1 and low[u] > tin[p])",
            "                bridge.emplace_back(min(u, p), max(u, p));",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(!vis[u])",
            "            {",
            "                dfs(u, -1, dfs);",
            "                bcc.push_back(vector<int> ());",
            "                while(!stk.empty())",
            "                {",
            "                    bcc[m].push_back(stk.back());",
            "                    stk.pop_back();",
            "                }",
            "                ++ m;",
            "            }",
            "        a = count(cut.begin(), cut.end(), true);",
            "    }",
            "",
            "    void make_block_cut_tree()",
            "    {",
            "        b = (m - n) + a;",
            "        bct_comp.assign(b, vector<int>());",
            "",
            "        for(int i = n; i < m; i ++)",
            "        {",
            "            bct_comp[i - n] = bcc[i];",
            "            for(auto u : bct_comp[i - n])",
            "                block_node_id[u] = i - n;",
            "        }",
            "",
            "        vector<int> cut_list;",
            "        for(int i = 0; i < n; i ++)",
            "            if(cut[i])",
            "                cut_list.push_back(i);",
            "            ",
            "        for(int i = m - n; i < m - n + a; i ++)",
            "        {",
            "            bct_comp[i] = {cut_list[i - (m - n)]};",
            "            for(auto u : bct_comp[i])",
            "                cut_node_id[u] = i;",
            "        }",
            "",
            "        for(int i = 0; i < m - n; i ++)",
            "            for(auto u : bct_comp[i])",
            "                if(cut[u])",
            "                    bct[i].push_back(cut_node_id[u]), bct[cut_node_id[u]].push_back(i);",
            "    }",
            "};"
        ],
        "description": "Snippet for connectivity"
    },
    "template_scc": {
        "prefix": "template_scc",
        "body": [
            "class condenser",
            "{",
            "    /*",
            "    https://github.com/welcome-to-the-sunny-side/libra/",
            "    ",
            "    tc: O(n + m)",
            "    ml: O(n + m)",
            "",
            "    info:",
            "        0-indexed    ",
            "        SCC u occurs before SCC v (u < v) in some topological ordering of SCCs ",
            "",
            "    warning: ",
            "        there may be multiple edges between different SCCs",
            "",
            "    var:",
            "        ",
            "        [n -> number of nodes]",
            "        [c -> number of SCCs]",
            "        [adj] -> G",
            "        [rdj] -> G.T",
            "        [comp[u] -> component number of node u]",
            "        [scc[u] -> outedge list for scc u]",
            "        [grp[u] -> node list for scc u]",
            "    */",
            "public:",
            "    int n, c;",
            "    vector<bool> vis;",
            "    vector<int> stak, comp;",
            "    vector<vector<int>> adj, rdj, scc, grp;",
            "",
            "    condenser(int n, const vector<vector<int>> &adj) :",
            "    n(n), c(0), vis(n), adj(adj), rdj(n), scc(n), grp(n), comp(n, -1) ",
            "    {",
            "        for(int u = 0; u < n; u ++)",
            "            for(auto v : adj[u])",
            "                rdj[v].push_back(u);",
            "    };",
            "",
            "    void condense()",
            "    {",
            "        auto dfs1 = [&](int u, auto &&dfs1) -> void ",
            "        {",
            "            vis[u] = true;",
            "            for(auto v : adj[u])",
            "                if(!vis[v])",
            "                    dfs1(v, dfs1);",
            "            stak.push_back(u);",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(!vis[u])",
            "                dfs1(u, dfs1);",
            "",
            "        auto dfs2 = [&](int u, auto &&dfs2) -> void ",
            "        {",
            "            comp[u] = c;",
            "            for(auto v : rdj[u])",
            "                if(comp[v] == -1)",
            "                    dfs2(v, dfs2);",
            "        };",
            "",
            "        reverse(stak.begin(), stak.end());",
            "        for(auto u : stak)",
            "            if(comp[u] == -1)",
            "                dfs2(u, dfs2), ++ c;",
            "",
            "        for(int u = 0; u < n; u ++)",
            "            for(auto v : adj[u])",
            "                if(comp[u] != comp[v])",
            "                    scc[comp[u]].push_back(comp[v]);",
            "",
            "        for(int u = 0; u < n; u ++)",
            "            grp[comp[u]].push_back(u);",
            "    }",
            "",
            "    void fix()      //remove multiple edges [O(m log(m))]",
            "    {",
            "        for(auto &v : scc)",
            "        {",
            "            sort(v.begin(), v.end());",
            "            v.erase(unique(v.begin(), v.end()), v.end());",
            "        }",
            "    }",
            "};"
        ],
        "description": "Snippet for scc"
    },
    "template_bipartite": {
        "prefix": "template_bipartite",
        "body": [
            "class bipartite_chan",
            "{",
            "    /*",
            "        tc: O(E sqrt(V))",
            "        mc: O(V + E)",
            "",
            "        vars:",
            "            n, m: size of left and right partitions",
            "            adj: left to right edges ONLY",
            "        info:",
            "            Both partitions are individually 1 indexed",
            "            After calling max_matching():",
            "                - matching = size of max matching",
            "                - l[u] = matched right node for u (l[u] = -1 => unmatched)",
            "                - r[u] = matched left node for u (r[u] = -1 => unmatched)",
            "            MVC is found by:",
            "                - orienting matched edges from right to left, unmatched opposite",
            "                - running dfs from all unmatched left side nodes",
            "                - (unvis nodes on the left) + (visited nodes on right) = mvc",
            "            MIS is complement of MVC",
            "    */",
            "public:",
            "    int n, m;",
            "    int matching = 0;",
            "    vector<vector<int>> adj;",
            "    vector<int> l, r, lvl;",
            "    bipartite_chan(int n, int m, const vector<vector<int>> &adj) : ",
            "        n(n), m(m), l(n, -1), r(m, -1), adj(adj) {};",
            "",
            "    // void Add(int u, int v)  { adj[u].push_back(v); }",
            "    bool dfs(int u)",
            "    {",
            "        int t = exchange(lvl[u], -1) + 1;",
            "        for (int v : adj[u])",
            "            if (r[v] == -1 or (lvl[r[v]] == t and dfs(r[v])))",
            "                return l[u] = v, r[v] = u, 1;",
            "        return 0;",
            "    }",
            "",
            "    int max_matching()",
            "    {",
            "        matching = 0;   ",
            "        vector<int> q(n);",
            "        for (int s = 0, t = 0;; s = t = 0)",
            "        {",
            "            lvl = vector<int>(n);   bool f = 0;",
            "            for(int i = 0; i < n; i ++) ",
            "                if (l[i] == -1) ",
            "                    lvl[i] = 1, q[t ++] = i;",
            "            ",
            "            while (s < t)",
            "            {",
            "                int u = q[ s++];",
            "                for (int v : adj[u])",
            "                {",
            "                    int x = r[v];",
            "                    if (x == -1)",
            "                        f = 1;",
            "                    else if (!lvl[x])",
            "                        lvl[x] = lvl[u] + 1, q[t++] = x;",
            "                }",
            "            }",
            "",
            "            if (!f)",
            "                break;",
            "            ",
            "            for(int i = 0; i < n; i ++) ",
            "                if (l[i] == -1) ",
            "                    matching += dfs(i);",
            "        }",
            "        return matching;",
            "    }",
            "",
            "    vector<pair<int, int>> max_matching_edges()",
            "    {",
            "        vector<pair<int, int>> mme;",
            "        for(int u = 0; u < n; u ++)",
            "            if(l[u] != -1)",
            "                mme.push_back(make_pair(u, l[u]));",
            "        return mme;",
            "    }",
            "    ",
            "    pair<vector<int>, vector<int>> min_vertex_cover()",
            "    {",
            "        vector<bool> lv(n, false), rv(m, false);",
            "        ",
            "        auto dfs = [&](int u, auto &&dfs) -> void",
            "        {",
            "            lv[u] = true;",
            "            for(auto v : adj[u])",
            "                if(r[v] != u and !rv[v])",
            "                {",
            "                    rv[v] = true;",
            "                    if(r[v] != -1 and !lv[r[v]])",
            "                        dfs(r[v], dfs);",
            "                }",
            "        };",
            "        for(int u = 0; u < n; u ++)",
            "            if(l[u] == -1 and !lv[u])",
            "                dfs(u, dfs);",
            "",
            "        vector<int> lc, rc;",
            "        for(int u = 0; u < n; u ++)",
            "            if(!lv[u])",
            "                lc.push_back(u);",
            "        for(int u = 0; u < m; u ++)",
            "            if(rv[u])",
            "                rc.push_back(u);",
            "        ",
            "        assert(matching == (int)lc.size() + (int)rc.size());",
            "        return {lc, rc};",
            "    }",
            "};"
        ],
        "description": "Snippet for bipartite"
    },
    "template_binary_lifter": {
        "prefix": "template_binary_lifter",
        "body": [
            "class binary_lifter_chan",
            "{",
            "    /*",
            "    tc: O(n logn) preprocessing, O(logn) query",
            "    ml: O(n logn)",
            "",
            "    info:",
            "        1 indexed",
            "        n -> number of nodes",
            "        r -> root of the tree",
            "        dep[u] -> depth of node u",
            "        tin[u], tout[u] -> intime, outtime of node u",
            "        up[u][i] -> stores 2^ith ancestor of u",
            "    */",
            "public:",
            "    int n, L, timer;",
            "    vector<int> dep, tin, tout;",
            "    vector<vector<int>> up;",
            "",
            "    binary_lifter_chan(int n, int r, const vector<vector<int>> &adj) : ",
            "    n(n), L(ceil(log2(n)) + 1), timer(0), dep(n), tin(n), tout(n), up(n, vector<int> (L, r))",
            "    {",
            "        timer = 0;",
            "        dep[r] = 0;",
            "        dfs(r, r, adj);",
            "    }",
            "",
            "    void dfs(int u, int p, const vector<vector<int>> &adj)",
            "    {",
            "        tin[u] = ++ timer;",
            "        up[u][0] = p;",
            " ",
            "        for(int i = 1; i < L; ++i)",
            "            up[u][i] = up[up[u][i - 1]][i - 1];",
            " ",
            "        for(auto v : adj[u])",
            "            if (v != p)",
            "                dep[v] = dep[u] + 1, dfs(v, u, adj);",
            "",
            "        tout[u] = ++ timer;",
            "    }",
            "",
            "    int get_kth(int v, int k)",
            "    {",
            "        if(k != 0)",
            "            for(int i = L - 1; i >= 0 and v > 0; i --)",
            "                if((1 << i) <= k)",
            "                    k -= (1 << i), v = up[v][i];",
            "        return v;",
            "    }",
            "",
            "    bool is_anc(int anc, int v)",
            "    {",
            "        return tin[anc] <= tin[v] and tout[v] <= tout[anc];",
            "    }",
            "",
            "    int lca(int u, int v)",
            "    {",
            "        if (is_anc(u, v))",
            "            return u;",
            "        if (is_anc(v, u))",
            "            return v;",
            "        for (int i = L - 1; i >= 0; --i) ",
            "            if (!is_anc(up[u][i], v))",
            "                u = up[u][i];",
            "        return up[u][0];",
            "    }",
            "};"
        ],
        "description": "Snippet for binary_lifter"
    },
    "template_level_ancestor": {
        "prefix": "template_level_ancestor",
        "body": [
            "//wip",
            "class level_ancestor_chan",
            "{",
            "public:",
            "    int n;",
            "    vector<int> tin;",
            "    vector<int> tout;",
            "    vector<int> heavy;",
            "",
            "    level_ancestor_chan(int n, int r, const vector<vector<int>> &tree) : ",
            "    n(n), heavy(n + 1), tin(n + 1), tout(n + 1)",
            "    {",
            "        auto adj = tree;",
            "        vector<int> sz(n + 1, 0);",
            "        auto dfs1 = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            sz[u] = 1;",
            "            if(p != 0)",
            "                adj[u].erase(find(adj[u].begin(), adj[u].end(), p));",
            "            for(auto v : adj[u])",
            "                dfs(v, u, dfs), sz[u] += sz[v];",
            "            if(!adj[u].empty())",
            "            {",
            "                auto mit = *max_element(adj[u].begin(), adj[u].end(), [&](int v1, int v2) {return sz[v1] < sz[v2];});",
            "                swap(*adj[u].begin(), mit);",
            "            }",
            "        };",
            "        dfs1(r, 0, dfs1);",
            "",
            "        int timer = 0;",
            "        auto dfs2 = [&](int u, int p, auto &&dfs) -> void",
            "        {",
            "            tin[]",
            "        };",
            "    };",
            "",
            "    bool is_anc(int a, int u)",
            "    {",
            "        return tin[a] <= tin[u] and tout[u] <= tout[a];",
            "    }",
            "",
            "    int lca(int u, int v)",
            "    {",
            "",
            "    }",
            "",
            "    int get_ancestor(int u, int k)",
            "    {",
            "",
            "    }",
            "};"
        ],
        "description": "Snippet for level_ancestor"
    },
    "template_offline_lca": {
        "prefix": "template_offline_lca",
        "body": [
            "vector<int> offline_lca_chan(int n, int r, const vector<vector<int>> &adj, vector<pair<int, int>> query)",
            "{",
            "    //dsu",
            "    vector<int> par(n), siz(n, 1);",
            "    iota(par.begin(), par.end(), 0);",
            "    auto get = [&](int u, auto &&get) -> int",
            "    {",
            "        return (par[u] == u ? u : par[u] = get(par[u], get));",
            "    };",
            "    auto unite = [&](int u, int v) -> void",
            "    {",
            "        u = get(u, get), v = get(v, get);",
            "        if(u == v)",
            "            return;",
            "        if(siz[u] < siz[v])",
            "            swap(u, v);",
            "        par[v] = u, siz[u] += siz[v];",
            "    };",
            "",
            "    assert(!query.empty());",
            "    int m = query.size();",
            "    ",
            "    vector<int> ans(m);",
            "    vector<bool> see(m);",
            "    vector<vector<int>> store(n);",
            "",
            "    for(int i = 0; i < m; i ++)",
            "    {",
            "        auto [u, v] = query[i];",
            "        store[u].push_back(i), store[v].push_back(i);",
            "    }",
            "",
            "    auto dfs = [&](int u, int p, auto &&dfs) -> void",
            "    {",
            "        for(auto i : store[u])",
            "        {",
            "            if(see[i])",
            "                ans[i] = get(query[i].first == u ? query[i].second : query[i].first, get);",
            "            see[i] = true;",
            "        }",
            "",
            "        for(auto v : adj[u])",
            "            if(v != p)",
            "                dfs(v, u, dfs);",
            "",
            "        if(p != 0)",
            "            unite(u, p);",
            "    };",
            "    dfs(r, 0, dfs);",
            "    ",
            "    return ans;",
            "};"
        ],
        "description": "Snippet for offline_lca"
    },
    "template_virtual_tree": {
        "prefix": "template_virtual_tree",
        "body": [
            "template <typename L>",
            "vector<pair<int, int>> virtual_tree_chan(vector<int> key, const vector<int> &tin, const vector<int> &tout, L &lca)",
            "{",
            "    assert(!key.empty());",
            "    sort(key.begin(), key.end(), [&](int a, int b)  { return tin[a] < tin[b]; });",
            "",
            "    vector<int> l;",
            "    for (int i = 0; i < key.size() - 1; i++)",
            "        l.push_back(lca.LCA(key[i], key[i + 1]));",
            "    ",
            "    for (auto p : l)",
            "        key.push_back(p);",
            "    sort(key.begin(), key.end(), [&](int a, int b)  { return tin[a] < tin[b]; });",
            "    key.erase(unique(key.begin(), key.end()), key.end());",
            "    reverse(key.begin(), key.end());",
            "",
            "    // stk contains path from root to current node, key contains unvisited nodes",
            "    stack<int> stk;",
            "    vector<pair<int, int>> edge;",
            "",
            "    stk.push(key.back());",
            "    key.pop_back();",
            "",
            "    while (!stk.empty())",
            "    {",
            "        int u = stk.top();",
            "        if (!key.empty() and tin[u] <= tin[key.back()] and tout[key.back()] <= tout[u])",
            "        {",
            "            edge.push_back(make_pair(u, key.back()));",
            "            stk.push(key.back());",
            "            key.pop_back();",
            "            continue;",
            "        }",
            "        stk.pop();",
            "    }",
            "",
            "    return edge;",
            "}"
        ],
        "description": "Snippet for virtual_tree"
    },
    "template_random_suffix_tree": {
        "prefix": "template_random_suffix_tree",
        "body": [
            "template<typename C, typename L, typename G, typename R>",
            "class random_suffix_tree_chan",
            "{",
            "    /*",
            "    info:",
            "        - Based on  https://welcome-to-the-sunny-side.github.io/2024/08/16/Funny-Way-To-Construct-Suffix-Tree.html ",
            "        - Generates suffix tree using the leader split technique for a set of strings numbered from 0 to n - 1",
            "        - bool compare(int i, int j, int x) returns true if x-length prefix of strings i and j is equal, and false otherwise",
            "        - int length(int i) returns length of ith string",
            "        - int get(int i, int x) returns the xth integer of string i (1 based indexing)",
            "        - rng just needs to have rng(x) generating random integer in [0, x)",
            "    warning:",
            "        - has been stress tested but its pretty slow and not optimized at all: https://judge.yosupo.jp/submission/237581",
            "    */",
            "public:",
            "    int n, root;",
            "    vector<int> dep;",
            "    vector<int> nid;",
            "    vector<int> rep;",
            "    vector<vector<int>> adj;",
            "",
            "    random_suffix_tree_chan(int n, C compare, L length, G get, R rng) : ",
            "    n(n), dep(2 * n + 5), nid(2 * n + 5), rep(2 * n + 5, -1), adj(2 * n + 5)",
            "    {",
            "        vector<int> alive(n);",
            "        iota(alive.begin(), alive.end(), 0);",
            "",
            "        int timer = n - 1;",
            "        vector<int> dis(2 * n + 5);",
            "        vector<int> brk(2 * n + 5);",
            "",
            "        auto construct = [&](vector<int> a, auto &&construct) -> int",
            "        {",
            "            assert(!a.empty());",
            "",
            "            if(a.size() == 1)",
            "            {",
            "                int u = a[0];",
            "                nid[u] = u;",
            "                rep[u] = u;",
            "                return a[0];",
            "            }",
            "",
            "            int l = a[rng(a.size())];",
            "            a.erase(find(a.begin(), a.end(), l));",
            "            dis[l] = length(l);",
            "",
            "            for(auto v : a)",
            "            {",
            "                dis[v] = 0;",
            "                int s = 1, e = min(dis[l], length(v));",
            "                while(s <= e)",
            "                {",
            "                    int mid = (s + e)/2;",
            "                    if(compare(l, v, mid))",
            "                        s = mid + 1, dis[v] = mid;",
            "                    else",
            "                        e = mid - 1;",
            "                }",
            "            }",
            "",
            "            sort(a.begin(), a.end(), [&](int i, int j) {return dis[i] > dis[j];});",
            "            a.insert(a.begin(), l);",
            "",
            "            vector<int> nodes;",
            "",
            "            while(!a.empty())",
            "            {",
            "                int len = dis[a.back()];",
            "                vector<int> split;",
            "",
            "                int node = -1;",
            "",
            "                while(!a.empty() and dis[a.back()] == len)",
            "                {",
            "                    if(length(a.back()) == len)",
            "                    {",
            "                        if(node == -1)",
            "                            node = a.back(), rep[node] = node;",
            "                        nid[a.back()] = node;",
            "                    }",
            "                    else",
            "                        split.push_back(a.back());",
            "                    a.pop_back();",
            "                }",
            "",
            "                if(node == -1)",
            "                    node = ++ timer;",
            "",
            "                dep[node] = len;",
            "",
            "                for(auto u : split)",
            "                    brk[u] = get(u, len + 1);",
            "                ",
            "                sort(split.begin(), split.end(), [&](int i, int j) {return brk[i] < brk[j];});",
            "                ",
            "                for(int i = 0; i < split.size();)",
            "                {",
            "                    int j = i;",
            "                    while(j < split.size() and brk[split[i]] == brk[split[j]])",
            "                        ++ j;",
            "                    ",
            "                    vector<int> hsplit;",
            "                    for(int k = i; k < j; k ++)",
            "                        hsplit.push_back(split[k]);",
            "                    ",
            "                    int child = construct(hsplit, construct);",
            "",
            "                    adj[node].push_back(child);",
            "                    rep[node] = max(rep[node], rep[child]);",
            "",
            "                    i = j;",
            "                }",
            "              ",
            "                nodes.push_back(node);",
            "            }",
            "",
            "            for(int i = 0; i < nodes.size() - 1; i ++)",
            "            {",
            "                adj[nodes[i]].push_back(nodes[i + 1]);",
            "                rep[nodes[i]] = max(rep[nodes[i]], rep[nodes[i + 1]]);",
            "            }",
            "",
            "            return nodes.front();",
            "        };",
            "        root = construct(alive, construct);",
            "",
            "        if(dep[root] != 0)",
            "        {",
            "            int new_root = ++ timer;",
            "            adj[new_root].push_back(root);",
            "            dep[new_root] = 0;",
            "            rep[new_root] = rep[root];",
            "            root = new_root;",
            "        }",
            "",
            "        for(int u = 0; u < adj.size(); u ++)",
            "        {",
            "            for(auto v : adj[u])",
            "                brk[v] = get(rep[v], dep[u] + 1);",
            "",
            "            sort(adj[u].begin(), adj[u].end(), ",
            "            [&](int i, int j) {return brk[i] < brk[j];});",
            "        }",
            "    };",
            "};"
        ],
        "description": "Snippet for random_suffix_tree"
    },
    "sport_hacker": {
        "prefix": "sport_hacker",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"../libra/misc/dbg.h\"",
            "#else",
            "#define debug(...)",
            "#define endl \"\\\\n\"",
            "#endif",
            "",
            "void main_()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    for(int tt = 1; tt <= t; tt ++)",
            "    {",
            "        ifstream fin(\"inp.txt\");",
            "        ofstream fout(\"out.txt\");",
            "",
            "        $0",
            "    }",
            "}",
            "",
            "static void run_with_stack_size(void (*func)(void), size_t stsize)",
            "{",
            "    char *stack, *send;",
            "    stack = (char *)malloc(stsize);",
            "    send = stack + stsize - 16;",
            "    send = (char *)((uintptr_t)send / 16 * 16);",
            "    asm volatile(",
            "        \"mov %%rsp, (%0)\\\\n\"",
            "        \"mov %0, %%rsp\\\\n\"",
            "        :",
            "        : \"r\"(send));",
            "    func();",
            "    asm volatile(\"mov (%0), %%rsp\\\\n\" : : \"r\"(send));",
            "    free(stack);",
            "}",
            "",
            "int32_t main()",
            "{",
            "    run_with_stack_size(main_, 1024 * 1024 * 1024); // run with a 1 GiB stack",
            "    return 0;",
            "}"
        ],
        "description": "Snippet for hacker_cup"
    },
    "template_pragma": {
        "prefix": "template_pragma",
        "body": [
            "#include <bits/allocator.h>",
            "#pragma GCC optimize(\"O3,unroll-loops\")",
            "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")"
        ],
        "description": "Snippet for pragma"
    },
    "template_random": {
        "prefix": "template_random",
        "body": [
            "struct random : std::mt19937",
            "{",
            "    using std::mt19937::mt19937;",
            "    using std::mt19937::operator();",
            "    static int64_t gen_seed()",
            "    {",
            "        return std::chrono::steady_clock::now().time_since_epoch().count();",
            "    }",
            "    random() : std::mt19937(gen_seed()) {}",
            "    template <class Int>",
            "    auto operator()(Int a, Int b)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(a, b)(*this);",
            "    }",
            "    template <class Int>",
            "    auto operator()(Int a) -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(0, a - 1)(*this);",
            "    }",
            "    template <class Real>",
            "    auto operator()(Real a, Real b)",
            "        -> std::enable_if_t<std::is_floating_point_v<Real>, Real>",
            "    {",
            "        return std::uniform_real_distribution<Real>(a, b)(*this);",
            "    }",
            "};"
        ],
        "description": "Snippet for random"
    },
    "template_random64": {
        "prefix": "template_random64",
        "body": [
            "struct random64 : std::mt19937_64",
            "{",
            "    using std::mt19937_64::mt19937_64;",
            "    using std::mt19937_64::operator();",
            "",
            "    static int64_t gen_seed()",
            "    {",
            "        return std::chrono::steady_clock::now().time_since_epoch().count();",
            "    }",
            "",
            "    random64() : std::mt19937_64(gen_seed()) {}",
            "",
            "    template <class Int>",
            "    auto operator()(Int a, Int b)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(a, b)(*this);",
            "    }",
            "",
            "    template <class Int>",
            "    auto operator()(Int a)",
            "        -> std::enable_if_t<std::is_integral_v<Int>, Int>",
            "    {",
            "        return std::uniform_int_distribution<Int>(0, a - 1)(*this);",
            "    }",
            "",
            "    template <class Real>",
            "    auto operator()(Real a, Real b)",
            "        -> std::enable_if_t<std::is_floating_point_v<Real>, Real>",
            "    {",
            "        return std::uniform_real_distribution<Real>(a, b)(*this);",
            "    }",
            "};"
        ],
        "description": "Snippet for random64"
    },
    "sport": {
        "prefix": "sport",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"../libra/misc/dbg.h\"",
            "#else",
            "#define debug(...)",
            "#define endl \"\\\\n\"",
            "#endif",
            "",
            "signed main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int t = 1;",
            "    cin >> t;",
            "    while(t --)",
            "    {",
            "        // $0",
            "    }",
            "}"
        ],
        "description": "Snippet for template"
    },
    "template_time": {
        "prefix": "template_time",
        "body": [
            "auto start = std::chrono::high_resolution_clock::now();",
            "// Code to benchmark",
            "auto end = std::chrono::high_resolution_clock::now();",
            "auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start).count();",
            "std::cout << \"Execution time: \" << duration << \" microseconds\" << std::endl;"
        ],
        "description": "Snippet for time"
    },
    "template_hash_map": {
        "prefix": "template_hash_map",
        "body": [
            "// #include<bits/extc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "struct splitmix64_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};",
            "",
            "template <typename K, typename V, typename Hash = splitmix64_hash>",
            "using HashMap = __gnu_pbds::gp_hash_table<K, V, Hash>;",
            "",
            "template <typename K, typename Hash = splitmix64_hash>",
            "using HashSet = HashMap<K, __gnu_pbds::null_type, Hash>;"
        ],
        "description": "Snippet for hash_map"
    },
    "template_int_128": {
        "prefix": "template_int_128",
        "body": [
            "// int128 bit for numbers larger than 1e18. Will support numbers till 1e36",
            "// Comment out everything related to PBDS while using this",
            "// Put all the code in the same order",
            "",
            "// Typedef to ell",
            "typedef __int128 ell;",
            "",
            "// For printing",
            "std::ostream&",
            "operator<<( std::ostream& dest, __int128_t value ) {",
            "\tstd::ostream::sentry s( dest );",
            "\tif ( s ) {",
            "\t\t__uint128_t tmp = value < 0 ? -value : value; char buffer[ 128 ];",
            "\t\tchar* d = std::end( buffer );",
            "\t\tdo {\t-- d; *d = \"0123456789\"[ tmp % 10 ]; tmp /= 10;} while ( tmp != 0 );",
            "\t\tif ( value < 0 ) {-- d; *d = '-';}",
            "\t\tint len = std::end( buffer ) - d;",
            "\t\tif ( dest.rdbuf()->sputn( d, len ) != len ) {dest.setstate( std::ios_base::badbit );}",
            "\t}",
            "\treturn dest;",
            "}",
            "",
            "// For reading _int128 to_read = read()",
            "__int128 read() {",
            "\t__int128 x = 0, f = 1;",
            "\tchar ch = getchar();",
            "\twhile (ch < '0' || ch > '9') {if (ch == '-') f = -1; ch = getchar();}",
            "\twhile (ch >= '0' && ch <= '9') {x = x * 10 + ch - '0'; ch = getchar();}",
            "\treturn x * f;",
            "}",
            "",
            "// For debugging",
            "void _print(ell t) {cerr << t;}"
        ],
        "description": "Snippet for int_128"
    },
    "template_min_pq": {
        "prefix": "template_min_pq",
        "body": [
            "template<typename T>",
            "using MinPQ = priority_queue<T, vector<T>, greater<T>>;"
        ],
        "description": "Snippet for min_pq"
    },
    "template_ordered_set": {
        "prefix": "template_ordered_set",
        "body": [
            "// #include<bits/extc++.h>",
            "#include <ext/pb_ds/assoc_container.hpp>",
            "",
            "template <typename K, typename V, typename Comp = std::less<K>>",
            "using ordered_map = __gnu_pbds::tree<",
            "    K, V, Comp,",
            "    __gnu_pbds::rb_tree_tag,",
            "    __gnu_pbds::tree_order_statistics_node_update",
            ">;",
            "",
            "template<class T> using", 
            "ordered_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;",
            "template <typename K, typename Comp = std::less<K>>",
            "using ordered_set = ordered_map<K, __gnu_pbds::null_type, Comp>;",
            "",
            "// Supports",
            "//  auto iterator = ordered_set().find_by_order(idx); // (0-indexed)",
            "//  int num_strictly_smaller = ordered_set().order_of_key(key);"
        ],
        "description": "Snippet for ordered_set"
    },
    "template_SolnCorrect": {
        "prefix": "template_SolnCorrect",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a, b;",
            "    cin >> a >> b;",
            "    cout << a + b << endl;",
            "}"
        ],
        "description": "Snippet for SolnCorrect"
    },
    "template_SolnMy": {
        "prefix": "template_SolnMy",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a, b;",
            "    cin >> a >> b;",
            "    cout << a + b << endl;",
            "}"
        ],
        "description": "Snippet for SolnMy"
    },
    "template_TestGenerator": {
        "prefix": "template_TestGenerator",
        "body": [
            "#include<bits/stdc++.h>",
            "#pragma GCC optimize(\"O3\")",
            "",
            "using namespace std;",
            "",
            "#ifdef natural_selection",
            "#include \"/dbg.h\"",
            "#else",
            "#define endl \"\\\\n\"",
            "#define debug(...)",
            "#endif",
            "",
            "const int64_t inf = 1e9+9, INF = 1e18;",
            "",
            "//#define int int64_t",
            "",
            "const int N = 3e5+5;",
            "",
            "int32_t main()",
            "{",
            "    ios_base::sync_with_stdio(false), cin.tie(NULL);",
            "    int a = rand() % 10, b = rand() % 10;",
            "    cout << a << \" \" << b << endl; ",
            "}"
        ],
        "description": "Snippet for TestGenerator"
    },
    "template_combinatorics": {
        "prefix": "template_combinatorics",
        "body": [
            "template<typename T, const int P>",
            "class combinatorics",
            "{",
            "    //combinatorics<mint,2> c(200);",
            "    //2 is the number whose power will be precomputed",
            "public:",
            "    int n;",
            "    vector<T> inv, fac, ifac, pw;",
            "    combinatorics (int n) : n(n), inv(n+1), fac(n+1), ifac(n+1), pw(n+1)",
            "    {",
            "        fac[0] = inv[0] = ifac[0] = pw[0] = T(1);",
            " ",
            "        for(int i = 1; i <= n; i ++)",
            "            inv[i] = T(1)/T(i), fac[i] = fac[i - 1] * T(i), ifac[i] = ifac[i - 1] * inv[i], pw[i] = pw[i - 1] * T(P);",
            "    }",
            "",
            "    T ncr(int n, int r)",
            "    {",
            "        if(n < r or r < 0)",
            "            return 0;",
            "        return fac[n] * ifac[r] * ifac[n - r];",
            "    }",
            "};"
        ],
        "description": "Snippet for combinatorics"
    },
    "template_gaussian_elimination": {
        "prefix": "template_gaussian_elimination",
        "body": [
            "class gauss_chan",
            "{",
            "public:",
            "    int d, sz;",
            "    vector<int> basis;",
            "",
            "    gauss_chan (int d) : d(d), sz(0), basis(d) {};",
            "",
            "    void insert(int mask)",
            "    {",
            "        for(int i = 0; i < d; i ++) if(mask & (1 << i))",
            "        {",
            "            if(basis[i] == 0)",
            "            {",
            "                basis[i] = mask;",
            "                ++ sz;",
            "                break;",
            "            }",
            "            mask ^= basis[i];",
            "        }",
            "    }",
            "",
            "    void query()",
            "    {",
            "        //",
            "    }",
            "};"
        ],
        "description": "Snippet for gaussian_elimination"
    },
    "template_mod_int": {
        "prefix": "template_mod_int",
        "body": [
            "template <const int &MOD>",
            "struct modular_int",
            "{",
            "    int val;",
            "",
            "    modular_int(int64_t v = 0)",
            "    {",
            "        if (v < 0)",
            "            v = v % MOD + MOD;",
            "        if (v >= MOD)",
            "            v %= MOD;",
            "        val = int(v);",
            "    }",
            "",
            "    modular_int(uint64_t v)",
            "    {",
            "        if (v >= MOD)",
            "            v %= MOD;",
            "        val = int(v);",
            "    }",
            "",
            "    modular_int(int v) : modular_int(int64_t(v)) {}",
            "    modular_int(unsigned v) : modular_int(uint64_t(v)) {}",
            "",
            "    explicit operator int() const { return val; }",
            "    explicit operator unsigned() const { return val; }",
            "    explicit operator int64_t() const { return val; }",
            "    explicit operator uint64_t() const { return val; }",
            "    explicit operator double() const { return val; }",
            "    explicit operator long double() const { return val; }",
            "",
            "    modular_int &operator+=(const modular_int &other)",
            "    {",
            "        val -= MOD - other.val;",
            "        if (val < 0)",
            "            val += MOD;",
            "        return *this;",
            "    }",
            "",
            "    modular_int &operator-=(const modular_int &other)",
            "    {",
            "        val -= other.val;",
            "        if (val < 0)",
            "            val += MOD;",
            "        return *this;",
            "    }",
            "",
            "    static unsigned fast_mod(uint64_t x, unsigned m = MOD)",
            "    {",
            "#if !defined(_WIN32) || defined(_WIN64)",
            "        return unsigned(x % m);",
            "#endif",
            "        // Optimized mod for Codeforces 32-bit machines.",
            "        // x must be less than 2^32 * m for this to work, so that x / m fits in an unsigned 32-bit int.",
            "        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);",
            "        unsigned quot, rem;",
            "        asm(\"divl %4\\\\n\"",
            "            : \"=a\"(quot), \"=d\"(rem)",
            "            : \"d\"(x_high), \"a\"(x_low), \"r\"(m));",
            "        return rem;",
            "    }",
            "",
            "    modular_int &operator*=(const modular_int &other)",
            "    {",
            "        val = fast_mod(uint64_t(val) * other.val);",
            "        return *this;",
            "    }",
            "",
            "    modular_int &operator/=(const modular_int &other)",
            "    {",
            "        return *this *= other.inv();",
            "    }",
            "",
            "    friend modular_int operator+(const modular_int &a, const modular_int &b) { return modular_int(a) += b; }",
            "    friend modular_int operator-(const modular_int &a, const modular_int &b) { return modular_int(a) -= b; }",
            "    friend modular_int operator*(const modular_int &a, const modular_int &b) { return modular_int(a) *= b; }",
            "    friend modular_int operator/(const modular_int &a, const modular_int &b) { return modular_int(a) /= b; }",
            "",
            "    modular_int &operator++()",
            "    {",
            "        val = val == MOD - 1 ? 0 : val + 1;",
            "        return *this;",
            "    }",
            "",
            "    modular_int &operator--()",
            "    {",
            "        val = val == 0 ? MOD - 1 : val - 1;",
            "        return *this;",
            "    }",
            "",
            "    modular_int operator++(int)",
            "    {",
            "        modular_int before = *this;",
            "        ++*this;",
            "        return before;",
            "    }",
            "    modular_int operator--(int)",
            "    {",
            "        modular_int before = *this;",
            "        --*this;",
            "        return before;",
            "    }",
            "",
            "    modular_int operator-() const",
            "    {",
            "        return val == 0 ? 0 : MOD - val;",
            "    }",
            "",
            "    friend bool operator==(const modular_int &a, const modular_int &b) { return a.val == b.val; }",
            "    friend bool operator!=(const modular_int &a, const modular_int &b) { return a.val != b.val; }",
            "    friend bool operator<(const modular_int &a, const modular_int &b) { return a.val < b.val; }",
            "    friend bool operator>(const modular_int &a, const modular_int &b) { return a.val > b.val; }",
            "    friend bool operator<=(const modular_int &a, const modular_int &b) { return a.val <= b.val; }",
            "    friend bool operator>=(const modular_int &a, const modular_int &b) { return a.val >= b.val; }",
            "",
            "    static const int SAVE_INV = int(1e6) + 5;",
            "    static modular_int save_inv[SAVE_INV];",
            "",
            "    static void prepare_inv()",
            "    {",
            "        // Ensures that MOD is prime, which is necessary for the inverse algorithm below.",
            "        for (int64_t p = 2; p * p <= MOD; p += p % 2 + 1)",
            "            assert(MOD % p != 0);",
            "",
            "        save_inv[0] = 0;",
            "        save_inv[1] = 1;",
            "",
            "        for (int i = 2; i < SAVE_INV; i++)",
            "            save_inv[i] = save_inv[MOD % i] * (MOD - MOD / i);",
            "    }",
            "",
            "    modular_int inv() const",
            "    {",
            "        if (save_inv[1] == 0)",
            "            prepare_inv();",
            "",
            "        if (val < SAVE_INV)",
            "            return save_inv[val];",
            "",
            "        modular_int product = 1;",
            "        int v = val;",
            "",
            "        do",
            "        {",
            "            product *= MOD - MOD / v;",
            "            v = MOD % v;",
            "        } while (v >= SAVE_INV);",
            "",
            "        return product * save_inv[v];",
            "    }",
            "",
            "    modular_int pow(int64_t p) const",
            "    {",
            "        if (p < 0)",
            "            return inv().pow(-p);",
            "",
            "        modular_int a = *this, result = 1;",
            "",
            "        while (p > 0)",
            "        {",
            "            if (p & 1)",
            "                result *= a;",
            "",
            "            p >>= 1;",
            "",
            "            if (p > 0)",
            "                a *= a;",
            "        }",
            "",
            "        return result;",
            "    }",
            "",
            "    friend ostream &operator<<(ostream &os, const modular_int &m)",
            "    {",
            "        return os << m.val;",
            "    }",
            "};",
            "template <const int &MOD>",
            "modular_int<MOD> modular_int<MOD>::save_inv[modular_int<MOD>::SAVE_INV];",
            "const int MOD = 998244353;",
            "using mint = modular_int<MOD>;",
            "void __print(mint x) { cerr << x; }"
        ],
        "description": "Snippet for mod_int"
    },
    "template_mod_int_variable": {
        "prefix": "template_mod_int_variable",
        "body": [
            "",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "        // @param m `1 <= m`",
            "        // @return x mod m",
            "        constexpr long long safe_mod(long long x, long long m)",
            "        {",
            "            x %= m;",
            "            if (x < 0)",
            "                x += m;",
            "            return x;",
            "        }",
            "",
            "        // Fast modular multiplication by barrett reduction",
            "        // Reference: https://en.wikipedia.org/wiki/Barrett_reduction",
            "        // NOTE: reconsider after Ice Lake",
            "        struct barrett",
            "        {",
            "            unsigned int _m;",
            "            unsigned long long im;",
            "",
            "            // @param m `1 <= m`",
            "            explicit barrett(unsigned int m) : _m(m), im((unsigned long long)(-1) / m + 1) {}",
            "",
            "            // @return m",
            "            unsigned int umod() const { return _m; }",
            "",
            "            // @param a `0 <= a < m`",
            "            // @param b `0 <= b < m`",
            "            // @return `a * b % m`",
            "            unsigned int mul(unsigned int a, unsigned int b) const",
            "            {",
            "                // [1] m = 1",
            "                // a = b = im = 0, so okay",
            "",
            "                // [2] m >= 2",
            "                // im = ceil(2^64 / m)",
            "                // -> im * m = 2^64 + r (0 <= r < m)",
            "                // let z = a*b = c*m + d (0 <= c, d < m)",
            "                // a*b * im = (c*m + d) * im = c*(im*m) + d*im = c*2^64 + c*r + d*im",
            "                // c*r + d*im < m * m + m * im < m * m + 2^64 + m <= 2^64 + m * (m + 1) < 2^64 * 2",
            "                // ((ab * im) >> 64) == c or c + 1",
            "                unsigned long long z = a;",
            "                z *= b;",
            "#ifdef _MSC_VER",
            "                unsigned long long x;",
            "                _umul128(z, im, &x);",
            "#else",
            "                unsigned long long x =",
            "                    (unsigned long long)(((unsigned __int128)(z)*im) >> 64);",
            "#endif",
            "                unsigned long long y = x * _m;",
            "                return (unsigned int)(z - y + (z < y ? _m : 0));",
            "            }",
            "        };",
            "",
            "        // @param n `0 <= n`",
            "        // @param m `1 <= m`",
            "        // @return `(x ** n) % m`",
            "        constexpr long long pow_mod_constexpr(long long x, long long n, int m)",
            "        {",
            "            if (m == 1)",
            "                return 0;",
            "            unsigned int _m = (unsigned int)(m);",
            "            unsigned long long r = 1;",
            "            unsigned long long y = safe_mod(x, m);",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r = (r * y) % _m;",
            "                y = (y * y) % _m;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "",
            "        // Reference:",
            "        // M. Forisek and J. Jancina,",
            "        // Fast Primality Testing for Integers That Fit into a Machine Word",
            "        // @param n `0 <= n`",
            "        constexpr bool is_prime_constexpr(int n)",
            "        {",
            "            if (n <= 1)",
            "                return false;",
            "            if (n == 2 || n == 7 || n == 61)",
            "                return true;",
            "            if (n % 2 == 0)",
            "                return false;",
            "            long long d = n - 1;",
            "            while (d % 2 == 0)",
            "                d /= 2;",
            "            constexpr long long bases[3] = {2, 7, 61};",
            "            for (long long a : bases)",
            "            {",
            "                long long t = d;",
            "                long long y = pow_mod_constexpr(a, t, n);",
            "                while (t != n - 1 && y != 1 && y != n - 1)",
            "                {",
            "                    y = y * y % n;",
            "                    t <<= 1;",
            "                }",
            "                if (y != n - 1 && t % 2 == 0)",
            "                {",
            "                    return false;",
            "                }",
            "            }",
            "            return true;",
            "        }",
            "        template <int n>",
            "        constexpr bool is_prime = is_prime_constexpr(n);",
            "",
            "        // @param b `1 <= b`",
            "        // @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g",
            "        constexpr std::pair<long long, long long> inv_gcd(long long a, long long b)",
            "        {",
            "            a = safe_mod(a, b);",
            "            if (a == 0)",
            "                return {b, 0};",
            "",
            "            // Contracts:",
            "            // [1] s - m0 * a = 0 (mod b)",
            "            // [2] t - m1 * a = 0 (mod b)",
            "            // [3] s * |m1| + t * |m0| <= b",
            "            long long s = b, t = a;",
            "            long long m0 = 0, m1 = 1;",
            "",
            "            while (t)",
            "            {",
            "                long long u = s / t;",
            "                s -= t * u;",
            "                m0 -= m1 * u; // |m1 * u| <= |m1| * s <= b",
            "",
            "                // [3]:",
            "                // (s - t * u) * |m1| + t * |m0 - m1 * u|",
            "                // <= s * |m1| - t * u * |m1| + t * (|m0| + |m1| * u)",
            "                // = s * |m1| + t * |m0| <= b",
            "",
            "                auto tmp = s;",
            "                s = t;",
            "                t = tmp;",
            "                tmp = m0;",
            "                m0 = m1;",
            "                m1 = tmp;",
            "            }",
            "            // by [3]: |m0| <= b/g",
            "            // by g != b: |m0| < b/g",
            "            if (m0 < 0)",
            "                m0 += b / s;",
            "            return {s, m0};",
            "        }",
            "",
            "        // Compile time primitive root",
            "        // @param m must be prime",
            "        // @return primitive root (and minimum in now)",
            "        constexpr int primitive_root_constexpr(int m)",
            "        {",
            "            if (m == 2)",
            "                return 1;",
            "            if (m == 167772161)",
            "                return 3;",
            "            if (m == 469762049)",
            "                return 3;",
            "            if (m == 754974721)",
            "                return 11;",
            "            if (m == 998244353)",
            "                return 3;",
            "            int divs[20] = {};",
            "            divs[0] = 2;",
            "            int cnt = 1;",
            "            int x = (m - 1) / 2;",
            "            while (x % 2 == 0)",
            "                x /= 2;",
            "            for (int i = 3; (long long)(i)*i <= x; i += 2)",
            "            {",
            "                if (x % i == 0)",
            "                {",
            "                    divs[cnt++] = i;",
            "                    while (x % i == 0)",
            "                    {",
            "                        x /= i;",
            "                    }",
            "                }",
            "            }",
            "            if (x > 1)",
            "            {",
            "                divs[cnt++] = x;",
            "            }",
            "            for (int g = 2;; g++)",
            "            {",
            "                bool ok = true;",
            "                for (int i = 0; i < cnt; i++)",
            "                {",
            "                    if (pow_mod_constexpr(g, (m - 1) / divs[i], m) == 1)",
            "                    {",
            "                        ok = false;",
            "                        break;",
            "                    }",
            "                }",
            "                if (ok)",
            "                    return g;",
            "            }",
            "        }",
            "        template <int m>",
            "        constexpr int primitive_root = primitive_root_constexpr(m);",
            "",
            "        // @param n `n < 2^32`",
            "        // @param m `1 <= m < 2^32`",
            "        // @return sum_{i=0}^{n-1} floor((ai + b) / m) (mod 2^64)",
            "        unsigned long long floor_sum_unsigned(unsigned long long n,",
            "                                              unsigned long long m,",
            "                                              unsigned long long a,",
            "                                              unsigned long long b)",
            "        {",
            "            unsigned long long ans = 0;",
            "            while (true)",
            "            {",
            "                if (a >= m)",
            "                {",
            "                    ans += n * (n - 1) / 2 * (a / m);",
            "                    a %= m;",
            "                }",
            "                if (b >= m)",
            "                {",
            "                    ans += n * (b / m);",
            "                    b %= m;",
            "                }",
            "",
            "                unsigned long long y_max = a * n + b;",
            "                if (y_max < m)",
            "                    break;",
            "                // y_max < m * (n + 1)",
            "                // floor(y_max / m) <= n",
            "                n = (unsigned long long)(y_max / m);",
            "                b = (unsigned long long)(y_max % m);",
            "                std::swap(m, a);",
            "            }",
            "            return ans;",
            "        }",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "#ifndef _MSC_VER",
            "        template <class T>",
            "        using is_signed_int128 =",
            "            typename std::conditional<std::is_same<T, __int128_t>::value ||",
            "                                          std::is_same<T, __int128>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int128 =",
            "            typename std::conditional<std::is_same<T, __uint128_t>::value ||",
            "                                          std::is_same<T, unsigned __int128>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using make_unsigned_int128 =",
            "            typename std::conditional<std::is_same<T, __int128_t>::value,",
            "                                      __uint128_t,",
            "                                      unsigned __int128>;",
            "",
            "        template <class T>",
            "        using is_integral = typename std::conditional<std::is_integral<T>::value ||",
            "                                                          is_signed_int128<T>::value ||",
            "                                                          is_unsigned_int128<T>::value,",
            "                                                      std::true_type,",
            "                                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_signed_int = typename std::conditional<(is_integral<T>::value &&",
            "                                                         std::is_signed<T>::value) ||",
            "                                                            is_signed_int128<T>::value,",
            "                                                        std::true_type,",
            "                                                        std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int =",
            "            typename std::conditional<(is_integral<T>::value &&",
            "                                       std::is_unsigned<T>::value) ||",
            "                                          is_unsigned_int128<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using to_unsigned = typename std::conditional<",
            "            is_signed_int128<T>::value,",
            "            make_unsigned_int128<T>,",
            "            typename std::conditional<std::is_signed<T>::value,",
            "                                      std::make_unsigned<T>,",
            "                                      std::common_type<T>>::type>::type;",
            "",
            "#else",
            "",
            "        template <class T>",
            "        using is_integral = typename std::is_integral<T>;",
            "",
            "        template <class T>",
            "        using is_signed_int =",
            "            typename std::conditional<is_integral<T>::value && std::is_signed<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using is_unsigned_int =",
            "            typename std::conditional<is_integral<T>::value &&",
            "                                          std::is_unsigned<T>::value,",
            "                                      std::true_type,",
            "                                      std::false_type>::type;",
            "",
            "        template <class T>",
            "        using to_unsigned = typename std::conditional<is_signed_int<T>::value,",
            "                                                      std::make_unsigned<T>,",
            "                                                      std::common_type<T>>::type;",
            "",
            "#endif",
            "",
            "        template <class T>",
            "        using is_signed_int_t = std::enable_if_t<is_signed_int<T>::value>;",
            "",
            "        template <class T>",
            "        using is_unsigned_int_t = std::enable_if_t<is_unsigned_int<T>::value>;",
            "",
            "        template <class T>",
            "        using to_unsigned_t = typename to_unsigned<T>::type;",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "namespace atcoder",
            "{",
            "",
            "    namespace internal",
            "    {",
            "",
            "        struct modint_base",
            "        {",
            "        };",
            "        struct static_modint_base : modint_base",
            "        {",
            "        };",
            "",
            "        template <class T>",
            "        using is_modint = std::is_base_of<modint_base, T>;",
            "        template <class T>",
            "        using is_modint_t = std::enable_if_t<is_modint<T>::value>;",
            "",
            "    } // namespace internal",
            "",
            "    template <int m, std::enable_if_t<(1 <= m)> * = nullptr>",
            "    struct static_modint : internal::static_modint_base",
            "    {",
            "        using mint = static_modint;",
            "",
            "    public:",
            "        static constexpr int mod() { return m; }",
            "        static mint raw(int v)",
            "        {",
            "            mint x;",
            "            x._v = v;",
            "            return x;",
            "        }",
            "",
            "        static_modint() : _v(0) {}",
            "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
            "        static_modint(T v)",
            "        {",
            "            long long x = (long long)(v % (long long)(umod()));",
            "            if (x < 0)",
            "                x += umod();",
            "            _v = (unsigned int)(x);",
            "        }",
            "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "        static_modint(T v)",
            "        {",
            "            _v = (unsigned int)(v % umod());",
            "        }",
            "",
            "        unsigned int val() const { return _v; }",
            "",
            "        mint &operator++()",
            "        {",
            "            _v++;",
            "            if (_v == umod())",
            "                _v = 0;",
            "            return *this;",
            "        }",
            "        mint &operator--()",
            "        {",
            "            if (_v == 0)",
            "                _v = umod();",
            "            _v--;",
            "            return *this;",
            "        }",
            "        mint operator++(int)",
            "        {",
            "            mint result = *this;",
            "            ++*this;",
            "            return result;",
            "        }",
            "        mint operator--(int)",
            "        {",
            "            mint result = *this;",
            "            --*this;",
            "            return result;",
            "        }",
            "",
            "        mint &operator+=(const mint &rhs)",
            "        {",
            "            _v += rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator-=(const mint &rhs)",
            "        {",
            "            _v -= rhs._v;",
            "            if (_v >= umod())",
            "                _v += umod();",
            "            return *this;",
            "        }",
            "        mint &operator*=(const mint &rhs)",
            "        {",
            "            unsigned long long z = _v;",
            "            z *= rhs._v;",
            "            _v = (unsigned int)(z % umod());",
            "            return *this;",
            "        }",
            "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "        mint operator+() const { return *this; }",
            "        mint operator-() const { return mint() - *this; }",
            "",
            "        mint pow(long long n) const",
            "        {",
            "            assert(0 <= n);",
            "            mint x = *this, r = 1;",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r *= x;",
            "                x *= x;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "        mint inv() const",
            "        {",
            "            if (prime)",
            "            {",
            "                assert(_v);",
            "                return pow(umod() - 2);",
            "            }",
            "            else",
            "            {",
            "                auto eg = internal::inv_gcd(_v, m);",
            "                assert(eg.first == 1);",
            "                return eg.second;",
            "            }",
            "        }",
            "",
            "        friend mint operator+(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) += rhs;",
            "        }",
            "        friend mint operator-(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) -= rhs;",
            "        }",
            "        friend mint operator*(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) *= rhs;",
            "        }",
            "        friend mint operator/(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) /= rhs;",
            "        }",
            "        friend bool operator==(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v == rhs._v;",
            "        }",
            "        friend bool operator!=(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v != rhs._v;",
            "        }",
            "",
            "    private:",
            "        unsigned int _v;",
            "        static constexpr unsigned int umod() { return m; }",
            "        static constexpr bool prime = internal::is_prime<m>;",
            "    };",
            "",
            "    template <int id>",
            "    struct dynamic_modint : internal::modint_base",
            "    {",
            "        using mint = dynamic_modint;",
            "",
            "    public:",
            "        static int mod() { return (int)(bt.umod()); }",
            "        static void set_mod(int m)",
            "        {",
            "            assert(1 <= m);",
            "            bt = internal::barrett(m);",
            "        }",
            "        static mint raw(int v)",
            "        {",
            "            mint x;",
            "            x._v = v;",
            "            return x;",
            "        }",
            "",
            "        dynamic_modint() : _v(0) {}",
            "        template <class T, internal::is_signed_int_t<T> * = nullptr>",
            "        dynamic_modint(T v)",
            "        {",
            "            long long x = (long long)(v % (long long)(mod()));",
            "            if (x < 0)",
            "                x += mod();",
            "            _v = (unsigned int)(x);",
            "        }",
            "        template <class T, internal::is_unsigned_int_t<T> * = nullptr>",
            "        dynamic_modint(T v)",
            "        {",
            "            _v = (unsigned int)(v % mod());",
            "        }",
            "",
            "        unsigned int val() const { return _v; }",
            "",
            "        mint &operator++()",
            "        {",
            "            _v++;",
            "            if (_v == umod())",
            "                _v = 0;",
            "            return *this;",
            "        }",
            "        mint &operator--()",
            "        {",
            "            if (_v == 0)",
            "                _v = umod();",
            "            _v--;",
            "            return *this;",
            "        }",
            "        mint operator++(int)",
            "        {",
            "            mint result = *this;",
            "            ++*this;",
            "            return result;",
            "        }",
            "        mint operator--(int)",
            "        {",
            "            mint result = *this;",
            "            --*this;",
            "            return result;",
            "        }",
            "",
            "        mint &operator+=(const mint &rhs)",
            "        {",
            "            _v += rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator-=(const mint &rhs)",
            "        {",
            "            _v += mod() - rhs._v;",
            "            if (_v >= umod())",
            "                _v -= umod();",
            "            return *this;",
            "        }",
            "        mint &operator*=(const mint &rhs)",
            "        {",
            "            _v = bt.mul(_v, rhs._v);",
            "            return *this;",
            "        }",
            "        mint &operator/=(const mint &rhs) { return *this = *this * rhs.inv(); }",
            "",
            "        mint operator+() const { return *this; }",
            "        mint operator-() const { return mint() - *this; }",
            "",
            "        mint pow(long long n) const",
            "        {",
            "            assert(0 <= n);",
            "            mint x = *this, r = 1;",
            "            while (n)",
            "            {",
            "                if (n & 1)",
            "                    r *= x;",
            "                x *= x;",
            "                n >>= 1;",
            "            }",
            "            return r;",
            "        }",
            "        mint inv() const",
            "        {",
            "            auto eg = internal::inv_gcd(_v, mod());",
            "            assert(eg.first == 1);",
            "            return eg.second;",
            "        }",
            "",
            "        friend mint operator+(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) += rhs;",
            "        }",
            "        friend mint operator-(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) -= rhs;",
            "        }",
            "        friend mint operator*(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) *= rhs;",
            "        }",
            "        friend mint operator/(const mint &lhs, const mint &rhs)",
            "        {",
            "            return mint(lhs) /= rhs;",
            "        }",
            "        friend bool operator==(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v == rhs._v;",
            "        }",
            "        friend bool operator!=(const mint &lhs, const mint &rhs)",
            "        {",
            "            return lhs._v != rhs._v;",
            "        }",
            "",
            "    private:",
            "        unsigned int _v;",
            "        static internal::barrett bt;",
            "        static unsigned int umod() { return bt.umod(); }",
            "    };",
            "    template <int id>",
            "    internal::barrett dynamic_modint<id>::bt(998244353);",
            "",
            "    using modint998244353 = static_modint<998244353>;",
            "    using modint1000000007 = static_modint<1000000007>;",
            "    using modint = dynamic_modint<-1>;",
            "",
            "    namespace internal",
            "    {",
            "",
            "        template <class T>",
            "        using is_static_modint = std::is_base_of<internal::static_modint_base, T>;",
            "",
            "        template <class T>",
            "        using is_static_modint_t = std::enable_if_t<is_static_modint<T>::value>;",
            "",
            "        template <class>",
            "        struct is_dynamic_modint : public std::false_type",
            "        {",
            "        };",
            "        template <int id>",
            "        struct is_dynamic_modint<dynamic_modint<id>> : public std::true_type",
            "        {",
            "        };",
            "",
            "        template <class T>",
            "        using is_dynamic_modint_t = std::enable_if_t<is_dynamic_modint<T>::value>;",
            "",
            "    } // namespace internal",
            "",
            "} // namespace atcoder",
            "",
            "using mint = atcoder::dynamic_modint<-1>;",
            "// mint::set_mod(variable_mod)"
        ],
        "description": "Snippet for mod_int_variable"
    },
    "template_kmp": {
        "prefix": "template_kmp",
        "body": [
            "template <typename T>",
            "vector<int> kmp_table(const T &s)",
            "{",
            "    /*",
            "        tc: O(|s|)",
            "        mc: O(|s|)",
            "",
            "        info:",
            "            p[i] = longest suffix of substring s[0, 1, .. i] which is also a suffix ",
            "    */",
            "    int n = s.size();",
            "    vector<int> p(n, 0);",
            "    int k = 0;",
            "    for (int i = 1; i < n; i ++)",
            "    {",
            "        while (k > 0 && !(s[i] == s[k]))",
            "            k = p[k - 1];",
            "        if (s[i] == s[k])",
            "            k ++;",
            "        p[i] = k;",
            "    }",
            "    return p;",
            "}",
            "",
            "template <typename T>",
            "vector<int> kmp_search(const T &s, const T &w, const vector<int> &p)",
            "{",
            "    /*",
            "        tc: O(|s| + |w|)",
            "        mc: O(|w|)",
            "",
            "        info:",
            "            finds 0-indexed positions of occurences of s in w",
            "            p is kmp table of s",
            "    */",
            "    int n = s.size(), m = w.size();",
            "    assert(n >= 1 && (int)p.size() == n);",
            "    vector<int> res;",
            "    int k = 0;",
            "    for (int i = 0; i < m; i ++)",
            "    {",
            "        while (k > 0 && (k == n || !(w[i] == s[k])))",
            "            k = p[k - 1];",
            "        if (w[i] == s[k])",
            "            k ++;",
            "        if (k == n)",
            "            res.push_back(i - n + 1);",
            "    }",
            "    return res;",
            "}"
        ],
        "description": "Snippet for kmp"
    },
    "template_manachers": {
        "prefix": "template_manachers",
        "body": [
            "template <typename T>",
            "vector<int> manachers_chan(const T &s)",
            "{",
            "    /*",
            "        tc: O(|s|)",
            "        mc: O(|s|)",
            "",
            "        info:",
            "            0-indexed",
            "            res[2 * i]  = odd RADIUS in position i",
            "            res[2 * i + 1] = even RADIUS between positions i and i + 1",
            "        ",
            "        ex:",
            "            s = \"abaa\" -> res = {0, 0, 1, 0, 0, 1, 0};",
            "        ",
            "        author notes:",
            "            in other words, for every z from 0 to 2 * n - 2:",
            "            calculate i = (z + 1) >> 1 and j = z >> 1",
            "            now there is a palindrome from i - res[z] to j + res[z]",
            "            (watch out for i > j and res[z] = 0)",
            "    */",
            "    int n = (int)s.size();",
            "    if (n == 0)",
            "        return vector<int>();",
            "        ",
            "    vector<int> res(2 * n - 1, 0);",
            "    int l = -1, r = -1;",
            "    for (int z = 0; z < 2 * n - 1; z ++)",
            "    {",
            "        int i = (z + 1) >> 1, j = z >> 1;",
            "        int p = (i >= r ? 0 : min(r - i, res[2 * (l + r) - z]));",
            "",
            "        while (j + p + 1 < n and i - p - 1 >= 0 and (s[j + p + 1] == s[i - p - 1]))",
            "            p ++;",
            "",
            "        if (j + p > r)",
            "            l = i - p, r = j + p;",
            "        res[z] = p;",
            "    }",
            "",
            "    return res;",
            "}"
        ],
        "description": "Snippet for manachers"
    },
    "template_suffix_array": {
        "prefix": "template_suffix_array",
        "body": [
            "template <class T>",
            "array<vector<int>, 3> suffix_array_chan(const T &s, int max_num)",
            "{",
            "    /*",
            "        tc: O(|s|.log(|s|) + max_num)",
            "        mc: O(|s| + max_num)",
            "",
            "        info:",
            "            must pass s such that s[i] works as array index",
            "            returns {suffix array, inverse suffix array, lcp array}",
            "    */",
            "    int n = (int)size(s);",
            "    vector<int> sa(n), sa_inv(begin(s), end(s)), lcp(max(0, n - 1));",
            "    iota(begin(sa), end(sa), 0);",
            "    ",
            "    for (int ln = 0; ln < n; ln = max(1, 2 * ln))",
            "    {",
            "        vector<int> tmp(n), freq(max_num);",
            "        iota(begin(tmp), begin(tmp) + ln, n - ln);",
            "        copy_if(begin(sa), end(sa), begin(tmp) + ln, [&](int &x) { return (x -= ln) >= 0; });",
            "        for (int x : sa_inv)    freq[x]++;",
            "        ",
            "        partial_sum(begin(freq), end(freq), begin(freq));",
            "        for_each(rbegin(tmp), rend(tmp), [&](int x) { sa[--freq[sa_inv[x]]] = x; });",
            "        swap(sa_inv, tmp);",
            "        max_num = 1, sa_inv[sa[0]] = 0;",
            "        ",
            "        auto prev_inv = [&](int i) { return pair(tmp[i], i + ln < n ? tmp[i + ln] : -1); };",
            "        for (int i = 1; i < (n); i++)",
            "        {",
            "            max_num += prev_inv(sa[i - 1]) != prev_inv(sa[i]);",
            "            sa_inv[sa[i]] = max_num - 1;",
            "        }",
            "        if (max_num == n)",
            "            break;",
            "    }",
            "",
            "    int sz = 0;",
            "    for (int i = 0; i < (n); i++)",
            "    {",
            "        if (sz > 0)",
            "            sz--;",
            "        if (sa_inv[i] == 0)",
            "            continue;",
            "        for (int j = sa[sa_inv[i] - 1]; max(i, j) + sz < n && s[i + sz] == s[j + sz];)",
            "            sz++;",
            "        lcp[sa_inv[i] - 1] = sz;",
            "    }",
            "    return {sa, sa_inv, lcp};",
            "}"
        ],
        "description": "Snippet for suffix_array"
    },
    "template_suffix_tree": {
        "prefix": "template_suffix_tree",
        "body": [
            "class suffix_tree_chan",
            "{",
            "    /*",
            "    tc: O(n)",
            "    mc: O(n)",
            "",
            "    info:",
            "        0 indexed",
            "        pass it 0 indexed suffix array and lcp array",
            "        constructs suffix tree with the following properties:",
            "            1. node i (< n) represents suffix i (length = n - 1)",
            "            2. for every suffix there exists node in the suffix tree (even if it has only child)",
            "            3. if u > v, then u cannot be in the subtree of v",
            "            4. adj[u] contains downward edges from node u, sorted lexicography in order of strings on their labels",
            "            5. `root` is root node",
            "            6. dep[u] contains length of path from root to node u, used for edge labels",
            "            7. rep[u] = some i such that leaf for suffix i is in subtree of u ",
            "            8. m is the total number of nodes in the suffix tree (so m - n is the number of new internal nodes)",
            "",
            "        warning:",
            "            sa gets modified so dont pass by reference",
            "    */",
            "public:",
            "    int n, m, root;",
            "    vector<int> dep, rep;",
            "    vector<vector<int>> adj;",
            "",
            "    suffix_tree_chan(int n, vector<int> sa, vector<int> lcp) : ",
            "    n(n), m(n), dep(2 * n + 1), rep(2 * n + 1), adj(2 * n + 1)",
            "    {",
            "        vector<int> l(n), r(n);",
            "        for(int i = 0; i < n; i ++) ",
            "            l[i] = r[i] = rep[i] = i, dep[i] = n - i;",
            "        ",
            "        vector<vector<int>> q(n);",
            "        for(int i = 0; i < n - 1; i ++)",
            "            q[lcp[i]].push_back(i);",
            "        ",
            "        for(int d = n - 1; d >= 0; d --)",
            "            for(auto i : q[d])",
            "            {",
            "                int u;",
            "                if(dep[sa[i]] == d)",
            "                    u = sa[i], adj[u].push_back(sa[i + 1]);",
            "                else if(dep[sa[i + 1]] == d)",
            "                    u = sa[i + 1], adj[u].push_back(sa[i]);",
            "                else",
            "                    u = m ++, rep[u] = rep[sa[i]], adj[u] = {sa[i], sa[i + 1]};",
            "                ",
            "                dep[u] = d;",
            "                l[r[i + 1]] = l[i], r[l[i]] = r[i + 1];",
            "                sa[l[i]] = sa[r[i + 1]] = u;",
            "            }",
            "",
            "        root = sa[0];",
            "        if(dep[root] != 0)",
            "            root = m ++, dep[root] = 0, adj[root] = {sa[0]};",
            "    };",
            "};"
        ],
        "description": "Snippet for suffix_tree"
    },
    "template_z": {
        "prefix": "template_z",
        "body": [
            "template <typename T>",
            "vector<int> z_chan(const T &s)",
            "{",
            "    int n = s.size();",
            "    vector<int> z(n, n);",
            "    int l = 0, r = 0;",
            "    for (int i = 1; i < n; i++)",
            "    {",
            "        z[i] = (i > r ? 0 : min(r - i + 1, z[i - l]));",
            "        while (i + z[i] < n && s[z[i]] == s[i + z[i]])",
            "            z[i]++;",
            "",
            "        if (i + z[i] - 1 > r)",
            "            l = i, r = i + z[i] - 1;",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Snippet for z"
    },
    "template_fast_io": {
        "prefix": "template_fast_io",
        "body": [
            "namespace fast_io",
            "{",
            "    /*",
            "    warning:",
            "        remove custom fastio things",
            "    ",
            "    usage:",
            "        https://codeforces.com/contest/659/submission/128052727",
            "    */",
            "",
            "\tconstexpr int SIZE = (1 << 21) + 1;",
            "\tint num = 0, f;",
            "\tchar ibuf[SIZE], obuf[SIZE], que[65], *iS, *iT, *oS = obuf, *oT = obuf + SIZE - 1, c;",
            "\t#define gc() (iS == iT ? (iT = ((iS = ibuf) + fread(ibuf, 1, SIZE, stdin)), (iS == iT ? EOF : *iS ++)) : *iS ++)",
            "\tinline void flush()",
            "    {",
            "\t\tfwrite(obuf, 1, oS - obuf, stdout);",
            "\t\toS = obuf;",
            "\t}",
            "\tinline void putc(char c)",
            "    {",
            "\t\t*oS ++ = c;",
            "\t\tif (oS == oT) flush();",
            "\t}",
            "\tinline void getc(char &c) ",
            "    {",
            "\t\tfor (c = gc(); (c == ' ' || c == '\\\\0' || c == '\\\\n') && c != EOF; c = gc());",
            "\t}",
            "\tinline void reads(char *st) ",
            "    {",
            "\t\tchar c;",
            "\t\tint n = 0; ",
            "\t\tgetc(st[++ n]);",
            "\t\tfor (c = gc(); c != ' ' && c != '\\\\0' && c != '\\\\n' && c != EOF ; c = gc()) st[++ n] = c;",
            "\t\tst[++ n] = '\\\\0';",
            "\t}",
            "\ttemplate<class I>",
            "\tinline void read(I &x) ",
            "    {",
            "\t\tfor (f = 1, c = gc(); c < '0' || c > '9' ; c = gc()) if (c == '-') f = -1;",
            "\t\tfor (x = 0; c >= '0' && c <= '9' ; c = gc()) x = (x << 3) + (x << 1) + (c & 15);",
            "\t\tx *= f;",
            "\t}",
            "\ttemplate<class I>",
            "\tinline void print(I x) ",
            "    {",
            "\t\tif (x < 0) putc('-'), x = -x;",
            "\t\tif (!x) putc('0');",
            "\t\twhile (x) que[++ num] = x % 10 + 48, x /= 10;",
            "\t\twhile (num) putc(que[num --]);",
            "\t}",
            "\tinline void putstr(string st) ",
            "    {",
            "\t\tfor (int i = 0; i < (int)st.size() ; ++ i)  putc(st[i]);",
            "\t}",
            "\tstruct Flusher_{~Flusher_(){flush();}} io_Flusher_;",
            "}",
            "using fast_io :: read;",
            "using fast_io :: putc;",
            "using fast_io :: putstr;",
            "using fast_io :: getc;",
            "using fast_io :: reads;",
            "using fast_io :: print;"
        ],
        "description": "Snippet for fast_io"
    },
    "template_fast_set": {
        "prefix": "template_fast_set",
        "body": [
            "// https://codeforces.com/contest/1641/submission/147448352",
            "",
            "// D : 3 -> 2.6 * 10 ^ 5",
            "// D : 4 -> 1.6 * 10 ^ 7",
            "// D : 5 -> 1.0 * 10 ^ 9",
            "// D : 6 -> int \u306e\u7bc4\u56f2\u5168\u90e8",
            "",
            "const int not_found = 262144;",
            "",
            "template <const int D = 6> struct FastSet {",
            "    int n;",
            "    using u64 = uint64_t;",
            "    vector<u64> a[D];",
            "    FastSet(int n_ = (1 << std::min(31, D * 6))) : n(n_) {",
            "        for(int i = 0; i < D; i++) {",
            "            n_ = (n_ + 63) >> 6;",
            "            a[i].assign(n_, 0);",
            "        }",
            "    }",
            "    bool empty() const { return !a[D - 1][0]; }",
            "    bool contains(int x) const { return (a[0][x >> 6] >> (x & 63)) & 1; }",
            "    void insert(int x) {",
            "        for(int i = 0; i < D; i++) {",
            "            const int y = x & 63;",
            "            x >>= 6;",
            "            a[i][x] |= 1ULL << y;",
            "        }",
            "    }",
            "    void erase(int x) {",
            "        for(int i = 0; i < D; i++) {",
            "            const int y = x & 63;",
            "            x >>= 6;",
            "            if((a[i][x] &= ~(1ULL << y))) break;",
            "        }",
            "    }",
            "    int next(int x) const {             //smallest element >= x, returns 262144 if no such element",
            "        for(int i = 0; i < D; i++) {",
            "            const int k = x >> 6, y = x & 63;",
            "            if(k >= a[i].size()) return n;",
            "            const u64 top = a[i][k] >> y;",
            "            if(top) {",
            "                x += __builtin_ctzll(top);",
            "                for(int j = i - 1; j >= 0; --j) x = x << 6 | __builtin_ctzll(a[j][x]);",
            "                return x;",
            "            }",
            "            x = k + 1;",
            "        }",
            "        return n;",
            "    }",
            "    int prev(int x) const {            //largest element <= x",
            "        for(int i = 0; i < D; ++i) {",
            "            if(x < 0) return -1;",
            "            const int k = x >> 6, y = x & 63;",
            "            const u64 bot = a[i][k] << (63 - y);",
            "            if(bot) {",
            "                x -= __builtin_clzll(bot);",
            "                for(int j = i - 1; j >= 0; --j) x = x << 6 | (63 - __builtin_clzll(a[j][x]));",
            "                return x;",
            "            }",
            "            x = k - 1;",
            "        }",
            "        return -1;",
            "    }",
            "    int max() const { return prev(n); }",
            "    int min() const { return next(0); }",
            "};"
        ],
        "description": "Snippet for fast_set"
    },
    "template_ultra_fast_set": {
        "prefix": "template_ultra_fast_set",
        "body": [
            "using uint = unsigned int;",
            "using ull = unsigned long long;",
            "constexpr ull lowest_bitsll[] = {0ull, 1ull, 3ull, 7ull, 15ull, 31ull, 63ull, 127ull, 255ull, 511ull, 1023ull, 2047ull, 4095ull, 8191ull, 16383ull, 32767ull, 65535ull, 131071ull, 262143ull, 524287ull, 1048575ull, 2097151ull, 4194303ull, 8388607ull, 16777215ull, 33554431ull, 67108863ull, 134217727ull, 268435455ull, 536870911ull, 1073741823ull, 2147483647ull, 4294967295ull, 8589934591ull, 17179869183ull, 34359738367ull, 68719476735ull, 137438953471ull, 274877906943ull, 549755813887ull, 1099511627775ull, 2199023255551ull, 4398046511103ull, 8796093022207ull, 17592186044415ull, 35184372088831ull, 70368744177663ull, 140737488355327ull, 281474976710655ull, 562949953421311ull, 1125899906842623ull, 2251799813685247ull, 4503599627370495ull, 9007199254740991ull, 18014398509481983ull, 36028797018963967ull, 72057594037927935ull, 144115188075855871ull, 288230376151711743ull, 576460752303423487ull, 1152921504606846975ull, 2305843009213693951ull, 4611686018427387903ull, 9223372036854775807ull, 18446744073709551615ull};",
            "const uint NO = 1 << 20; // This value will be returned in lower_bound functions, if no answer exists. Change, if need.",
            "template <uint MAXN>     // Can correctly work with numbers in range [0; MAXN]",
            "class godgod_suc_pred",
            "{",
            "    static const uint PREF = (MAXN <= 64 ? 0 : MAXN <= 4096     ? 1",
            "                                           : MAXN <= 262144     ? 1 + 64",
            "                                           : MAXN <= 16777216   ? 1 + 64 + 4096",
            "                                           : MAXN <= 1073741824 ? 1 + 64 + 4096 + 262144",
            "                                                                : 227) +",
            "                             1;",
            "    static const uint SZ = PREF + (MAXN + 63) / 64 + 1;",
            "    ull m[SZ] = {0};",
            "",
            "    inline uint left(uint v) const { return (v - 62) * 64; }",
            "    inline uint parent(uint v) const { return v / 64 + 62; }",
            "    inline void setbit(uint v) { m[v >> 6] |= 1ull << (v & 63); }",
            "    inline void resetbit(uint v) { m[v >> 6] &= ~(1ull << (v & 63)); }",
            "    inline uint getbit(uint v) const { return m[v >> 6] >> (v & 63) & 1; }",
            "    inline ull childs_value(uint v) const { return m[left(v) >> 6]; }",
            "",
            "    inline uint left_go(uint x, const uint c) const",
            "    {",
            "        const ull rem = x & 63;",
            "        uint bt = PREF * 64 + x;",
            "        ull num = m[bt >> 6] & lowest_bitsll[rem + c];",
            "        if (num)",
            "            return (x ^ rem) | __lg(num);",
            "        for (bt = parent(bt); bt > 62; bt = parent(bt))",
            "        {",
            "            const ull rem = bt & 63;",
            "            num = m[bt >> 6] & lowest_bitsll[rem];",
            "            if (num)",
            "            {",
            "                bt = (bt ^ rem) | __lg(num);",
            "                break;",
            "            }",
            "        }",
            "        if (bt == 62)",
            "            return NO;",
            "        while (bt < PREF * 64)",
            "            bt = left(bt) | __lg(m[bt - 62]);",
            "        return bt - PREF * 64;",
            "    }",
            "",
            "    inline uint right_go(uint x, const uint c) const",
            "    {",
            "        const ull rem = x & 63;",
            "        uint bt = PREF * 64 + x;",
            "        ull num = m[bt >> 6] & ~lowest_bitsll[rem + c];",
            "        if (num)",
            "            return (x ^ rem) | __builtin_ctzll(num);",
            "        for (bt = parent(bt); bt > 62; bt = parent(bt))",
            "        {",
            "            const ull rem = bt & 63;",
            "            num = m[bt >> 6] & ~lowest_bitsll[rem + 1];",
            "            if (num)",
            "            {",
            "                bt = (bt ^ rem) | __builtin_ctzll(num);",
            "                break;",
            "            }",
            "        }",
            "        if (bt == 62)",
            "            return NO;",
            "        while (bt < PREF * 64)",
            "            bt = left(bt) | __builtin_ctzll(m[bt - 62]);",
            "        return bt - PREF * 64;",
            "    }",
            "",
            "public:",
            "    godgod_suc_pred()",
            "    {",
            "        assert(PREF != 228);",
            "        setbit(62);",
            "    }",
            "",
            "    bool empty() const { return getbit(63); }",
            "",
            "    void clear()",
            "    {",
            "        fill(m, m + SZ, 0);",
            "        setbit(62);",
            "    }",
            "",
            "    bool count(uint x) const { return m[PREF + (x >> 6)] >> (x & 63) & 1; }",
            "",
            "    void insert(uint x)",
            "    {",
            "        for (uint v = PREF * 64 + x; !getbit(v); v = parent(v))",
            "        {",
            "            setbit(v);",
            "        }",
            "    }",
            "",
            "    void erase(uint x)",
            "    {",
            "        if (!getbit(PREF * 64 + x))",
            "            return;",
            "        resetbit(PREF * 64 + x);",
            "        for (uint v = parent(PREF * 64 + x); v > 62 && !childs_value(v); v = parent(v))",
            "        {",
            "            resetbit(v);",
            "        }",
            "    }",
            "",
            "    uint lower_bound(uint x) const { return right_go(x, 0); }",
            "    uint upper_bound(uint x) const { return right_go(x, 1); }",
            "    uint inverse_lower_bound(uint x) const { return left_go(x, 1); }",
            "    uint inverse_upper_bound(uint x) const { return left_go(x, 0); }",
            "};",
            "// Supports all std::set operations in O(1) on random queries / dense arrays, O(log_64(N)) in worst case (sparce array).",
            "// Count operation works in O(1) always.",
            "//  reference : https://codeforces.com/contest/1793/submission/193330718"
        ],
        "description": "Snippet for ultra_fast_set"
    },
    "template_trie": {
        "prefix": "template_trie",
        "body": [
            "class Trie ",
            "{",
            "public:",
            "    static constexpr int ALPHA = 26;",
            "    vector<array<int,ALPHA>> nxt;",
            "    vector<int> cnt, pref;",
            "    int nodes;",
            "",
            "    Trie(int mx = 1e6+1) ",
            "    {",
            "        nxt.reserve(mx);",
            "        cnt.reserve(mx);",
            "        pref.reserve(mx);",
            "        newNode(); // create root",
            "    }",
            "",
            "    int newNode() ",
            "    {",
            "        nxt.push_back({});",
            "        cnt.push_back(0);",
            "        pref.push_back(0);",
            "        return nodes++;",
            "    }",
            "",
            "    // insert s with frequency f (use f=-1 to remove)",
            "    void insert(const string &s, int f = 1) ",
            "    {",
            "        int u = 0;",
            "        for (char ch : s) {",
            "            int c = ch - 'a';",
            "            if (!nxt[u][c]) {",
            "                nxt[u][c] = newNode();",
            "            }",
            "            u = nxt[u][c];",
            "            pref[u] += f;",
            "        }",
            "        cnt[u] += f;",
            "    }",
            "",
            "    // exact string count",
            "    int count(const string &s) const ",
            "    {",
            "        int u = 0;",
            "        for (char ch : s) ",
            "        {",
            "            int c = ch - 'a';",
            "            if (!nxt[u][c] || pref[nxt[u][c]] <= 0) ",
            "                return 0;",
            "            u = nxt[u][c];",
            "        }",
            "        return cnt[u];",
            "    }",
            "",
            "    // count of strings with prefix s",
            "    int prefCount(const string &s) const ",
            "    {",
            "        int u = 0;",
            "        for (char ch : s) {",
            "            int c = ch - 'a';",
            "            if (!nxt[u][c] || pref[nxt[u][c]] <= 0)",
            "                return 0;",
            "            u = nxt[u][c];",
            "        }",
            "        return pref[u];",
            "    }",
            "",
            "    // sum of prefCounts along path matching s",
            "    int query(const string &s) const ",
            "    {",
            "        // depends on use case",
            "",
            "        // int u = 0;",
            "        // int sum = 0;",
            "        // for (char ch : s) {",
            "        //     int c = ch - 'a';",
            "        //     if (!nxt[u][c]) break;",
            "        //     u = nxt[u][c];",
            "        //     sum += pref[u];",
            "        // }",
            "        // return sum;",
            "    }",
            "",
            "    // remove s (decrement counts)",
            "    void remove(const string &s) ",
            "    {",
            "        insert(s, -1);",
            "    }",
            "};"
        ],
        "description": "template_trie"
    },
    "template_bittrie": {
        "prefix": "template_bittrie",
        "body": [
            "class BitTrie ",
            "{",
            "public:",
            "    static constexpr int BITS = 31;       // for 32-bit ints use 31 down to 0",
            "    vector<array<int,2>> nxt;",
            "    vector<int> cnt;                      // count of numbers ending exactly at this node",
            "    vector<int> pref;                     // count of numbers passing through this node",
            "    int nodes = 0;",
            "",
            "    BitTrie(int maxNodes = 1e6+1) ",
            "    {",
            "        nxt.reserve(maxNodes);",
            "        cnt.reserve(maxNodes);",
            "        pref.reserve(maxNodes);",
            "        newNode();",
            "    }",
            "",
            "    int newNode() ",
            "    {",
            "        nxt.push_back({0,0});",
            "        cnt.push_back(0);",
            "        pref.push_back(0);",
            "        return nodes++;",
            "    }",
            "",
            "    // insert x (f=+1) or remove x (f=-1)",
            "    void insert(int x, int f = 1) ",
            "    {",
            "        int u = 0;",
            "        for (int b = BITS; b >= 0; --b) ",
            "        {",
            "            int bit = (x >> b) & 1;",
            "            if (!nxt[u][bit])",
            "                nxt[u][bit] = newNode();",
            "            u = nxt[u][bit];",
            "            pref[u] += f;",
            "        }",
            "        cnt[u] += f;",
            "    }",
            "",
            "    void remove(int x) { insert(x, -1); }",
            "",
            "    // exact count of x",
            "    int count(int x) const ",
            "    {",
            "        int u = 0;",
            "        for (int b = BITS; b >= 0; --b) ",
            "        {",
            "            int bit = (x >> b) & 1;",
            "            int v = nxt[u][bit];",
            "            if (!v || pref[v] <= 0) return 0;",
            "            u = v;",
            "        }",
            "        return cnt[u];",
            "    }",
            "",
            "    // maximize x^y over all y in the trie",
            "    int maxXor(int x) const ",
            "    {",
            "        int u = 0;",
            "        int ans = 0;",
            "        for (int b = BITS; b >= 0; --b) ",
            "        {",
            "            int bit = (x >> b) & 1;",
            "            int want = bit ^ 1;",
            "            if (nxt[u][want] && pref[nxt[u][want]] > 0) ",
            "            {",
            "                ans |= (1 << b);",
            "                u = nxt[u][want];",
            "            } else ",
            "            {",
            "                u = nxt[u][bit];",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    // count of elements  x",
            "    int leq(int x) const ",
            "    {",
            "        int u = 0, res = 0;",
            "        for (int b = BITS; b >= 0; --b) ",
            "        {",
            "            int bit = (x >> b) & 1;",
            "            if (bit == 1) ",
            "            {",
            "                if(nxt[u][0])",
            "                    res += pref[nxt[u][0]];",
            "                u = nxt[u][1];",
            "            } ",
            "            else ",
            "            {",
            "                u = nxt[u][0];",
            "            }",
            "        }",
            "        if(u) ",
            "            res += cnt[u];",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "template_bittrie"
    },
    "template_combinatorics2d": {
        "prefix": "template_combinatorics2d",
        "body": [
            "template<typename T>",
            "class combinatorics2d",
            "{   ",
            "    public:",
            "    int n;",
            "    vector<vector<T>> C;",
            "    combinatorics2d(int n) : n(n), C(n+1, vector<T>(n+1, 0)) ",
            "    {",
            "        for (int i = 0; i <= n; i++) ",
            "        {",
            "            C[i][0] = C[i][i] = T(1);   ",
            "            for (int j = 1; j < i; j++) ",
            "            {",
            "                C[i][j] = C[i-1][j-1] + C[i-1][j];",
            "            }",
            "        }",
            "    }",
            "",
            "    T ncr(int N, int R)",
            "    {",
            "        if (R < 0 || R > N) return T(0);",
            "        return C[N][R];",
            "    }",
            "};"
        ],
        "description": "template_combinatorics2d"
    },
    "template_disjoint_sparse_table": {
        "prefix": "template_disjoint_sparse_table",
        "body": [
            "template <typename T, typename F>",
            "class DisjointSparseTable {",
            " public:",
            "  int n;",
            "  vector<vector<T>> mat;",
            "  F func;",
            "",
            "  DisjointSparseTable(const vector<T>& a, const F& f) : n(int(a.size())), func(f) {",
            "    mat.push_back(a);",
            "    for (int p = 1; (1 << p) < n; p++) {",
            "      mat.emplace_back(n);",
            "      for (int mid = 1 << p; mid < n; mid += 1 << (p + 1)) {",
            "        mat[p][mid - 1] = a[mid - 1];",
            "        for (int j = mid - 2; j >= mid - (1 << p); j--) {",
            "          mat[p][j] = func(a[j], mat[p][j + 1]);",
            "        }",
            "        mat[p][mid] = a[mid];",
            "        for (int j = mid + 1; j < min(n, mid + (1 << p)); j++) {",
            "          mat[p][j] = func(mat[p][j - 1], a[j]);",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  T Query(int l, int r) const {",
            "    assert(0 <= l && l < r && r <= n);",
            "    if (r - l == 1) {",
            "      return mat[0][l];",
            "    }",
            "    int p = bit_width(unsigned(l ^ (r - 1))) - 1;",
            "    return func(mat[p][l], mat[p][r - 1]);",
            "  }",
            "};"
        ],
        "description": "template_disjoint_sparse_table"
    },
    "template_rref": {
  "prefix": "template_rref",
  "body": [
        "template<typename T>",
        "struct DynamicModularSystem {",
        "    int nvars;",
        "    vector<vector<T>> mat;    ",
        "    vector<int> pivot_col;    ",
        "    vector<int> where;        ",
        "    DynamicModularSystem(int nvars_) : nvars(nvars_), where(nvars_, -1) {}",
        "",
        "private:",
        "    bool isZero(const T &x)",
        "    {",
        "        return x == T(0);",
        "    }",
        "",
        "public:",
        "    bool addRow(vector<T> row) ",
        "    {",
        "        if ((int)row.size() != nvars + 1) throw runtime_error(\"row size mismatch\");",
        "        for (int i = 0; i < (int)mat.size(); ++i) ",
        "        {",
        "            int pcol = pivot_col[i];",
        "            if (pcol == -1) continue;",
        "            if (!isZero(row[pcol])) ",
        "            {",
        "                T factor = row[pcol];",
        "                for (int j = pcol; j <= nvars; ++j) ",
        "                {",
        "                    row[j] = row[j] - factor * mat[i][j];",
        "                }",
        "            }",
        "        }",
        "        int lead = -1;",
        "        for (int j = 0; j < nvars; ++j) if (!isZero(row[j])) { lead = j; break; }",
        "        if (lead == -1) ",
        "        {",
        "            if (!isZero(row[nvars])) return false;",
        "            return true;",
        "        }",
        "        T pivot_val = row[lead];",
        "       ",
        "        for (int j = lead; j <= nvars; ++j) ",
        "        {",
        "            row[j] = row[j] / pivot_val;",
        "        }",
        "        for (int i = 0; i < (int)mat.size(); ++i) ",
        "        {",
        "            if (!isZero(mat[i][lead])) ",
        "            {",
        "                T factor = mat[i][lead];",
        "                for (int j = lead; j <= nvars; ++j) ",
        "                {",
        "                    mat[i][j] = mat[i][j] - factor * row[j];",
        "                }",
        "            }",
        "        }",
        "        pivot_col.push_back(lead);",
        "        mat.push_back(row);",
        "        where[lead] = (int)mat.size() - 1;",
        "        return true;",
        "    }",
        "",
        "    pair<bool, vector<T>> solve() const ",
        "    {",
        "        vector<T> solution(nvars, T(0));",
        "        for (int r = 0; r < (int)mat.size(); ++r) ",
        "        {",
        "            int p = pivot_col[r];",
        "            if (p >= 0 && p < nvars) solution[p] = mat[r][nvars];",
        "        }",
        "        return {true, solution};",
        "    }",
        "",
        "    void printMatrix(ostream &out = cout) const ",
        "    {",
        "        for (auto &r : mat) ",
        "        {",
        "            for (int j = 0; j <= nvars; ++j) out << r[j] << ' ';",
        "            out << '\\n';",
        "        }",
        "    }",
        "",
        "    /*",
        "            DynamicModularSystem<double> sys(3);",
        "            sys.addRow({1.0, 2.0, 3.0, 1.0});",
        "            sys.addRow({2.0, 4.0, 6.0, 2.0});",
        "            sys.addRow({1.0, 0.0, 1.0, 3.0});",
        "            sys.printMatrix();",
        "            auto [ok, sol] = sys.solve();",
        "            for (auto &v : sol) cout << v << ' ';",
        "            cout << '\\n';",
        "    */",
        "};",
        ""
    ],
    "description": "template_rref"
    },
    "template_matrix_op": {
  "prefix": "template_matrix_op",
  "body": [
    "template <typename T, size_t N, size_t M, size_t K>",
    "array<array<T, K>, N> operator*(const array<array<T, M>, N>& a, const array<array<T, K>, M>& b) {",
    "  array<array<T, K>, N> c;",
    "  for (size_t i = 0; i < N; i++) {",
    "    for (size_t j = 0; j < K; j++) {",
    "      c[i][j] = 0;",
    "      for (size_t k = 0; k < M; k++) {",
    "        c[i][j] += a[i][k] * b[k][j];",
    "      }",
    "    }",
    "  }",
    "  return c;",
    "}",
    "",
    "template <typename T>",
    "vector<vector<T>> operator*(const vector<vector<T>>& a, const vector<vector<T>>& b) {",
    "  if (a.empty() || b.empty()) {",
    "    return {{}};",
    "  }",
    "  vector<vector<T>> c(a.size(), vector<T>(b[0].size()));",
    "  for (int i = 0; i < static_cast<int>(c.size()); i++) {",
    "    for (int j = 0; j < static_cast<int>(c[0].size()); j++) {",
    "      c[i][j] = 0;",
    "      for (int k = 0; k < static_cast<int>(b.size()); k++) {",
    "        c[i][j] += a[i][k] * b[k][j];",
    "      }",
    "    }",
    "  }",
    "  return c;",
    "}",
    "",
    "template <typename T>",
    "vector<vector<T>>& operator*=(vector<vector<T>>& a, const vector<vector<T>>& b) {",
    "  return a = a * b;",
    "}",
    "",
    "template <typename T, typename U>",
    "vector<vector<T>> power(const vector<vector<T>>& a, const U& b) {",
    "  assert(b >= 0);",
    "  vector<U> binary;",
    "  U bb = b;",
    "  while (bb > 0) {",
    "    binary.push_back(bb & 1);",
    "    bb >>= 1;",
    "  }",
    "  vector<vector<T>> res(a.size(), vector<T>(a.size()));",
    "  for (int i = 0; i < static_cast<int>(a.size()); i++) {",
    "    res[i][i] = 1;",
    "  }",
    "  for (int j = (int) binary.size() - 1; j >= 0; j--) {",
    "    res *= res;",
    "    if (binary[j] == 1) {",
    "      res *= a;",
    "    }",
    "  }",
    "  return res;",
    "}"
  ],
  "description": "template_matrix_op"
},
    "template_bridges": {
    "prefix": "template_bridges",
    "body": [
        "vector<bool> visited;",
        "vector<int> tin, low;",
        "int timer;",
        "timer = 0;",
        "visited.assign(n, false);",
        "tin.assign(n, -1);",
        "low.assign(n, -1);",
        "",
        "void dfs(int v, int p = -1) {",
        "    visited[v] = true;",
        "    tin[v] = low[v] = timer++;",
        "    bool parent_skipped = false;",
        "    for (int to : adj[v]) {",
        "        if (to == p && !parent_skipped) { // do this for multiple edges ",
        "            parent_skipped = true;",
        "            continue;",
        "        }",
        "        if (visited[to]) {",
        "            low[v] = min(low[v], tin[to]);",
        "        } else {",
        "            dfs(to, v);",
        "            low[v] = min(low[v], low[to]);",
        "            if (low[to] > tin[v])",
        "                IS_BRIDGE(v, to);",
        "        }",
        "    }",
        "}"
    ],
    "description": "template_bridges"
    },
    "template_fenwick2d": {
    "prefix": "template_fenwick2d",
    "body": [
        "template <typename T>",
        "class fenwick2d",
        "{",
        "    public:",
        "    int n, m;",
        "    vector<vector<T>> tree;",
        "    fenwick2d(int n, int m)",
        "    {",
        "        this->n = n;",
        "        this->m = m;",
        "        tree.assign(n+1,vector<T>(m+1,0));",
        "    }",
        "    void update(int x, int y, T val) ",
        "    {",
        "        for (int i = x; i <= n; i += (i & -i)) ",
        "        {",
        "            for (int j = y; j <= m; j += (j & -j)) ",
        "            {",
        "                tree[i][j] += val;",
        "            }",
        "        }",
        "    }",
        "    T query(int x, int y) ",
        "    {",
        "        T sum = 0;",
        "        for (int i = x; i > 0; i -= (i & -i)) ",
        "        {",
        "            for (int j = y; j > 0; j -= (j & -j)) ",
        "            {",
        "                sum += tree[i][j];",
        "            }",
        "        }",
        "        return sum;",
        "    }",
        "    T query(int x1, int y1, int x2, int y2) ",
        "    {",
        "        return query(x2, y2) ",
        "             - query(x1 - 1, y2) ",
        "             - query(x2, y1 - 1) ",
        "             + query(x1 - 1, y1 - 1);",
        "    }",
        "    // 1 based and [x1..x2]*[y1..y2]",
        "};"
    ],
    "description": "template_fenwick2d"
    },
    "template_simple_segtree": {
  "prefix": "template_simple_segtree",
  "body": [
    "template <class S, auto op, auto e, class F, auto mapping>",
    "struct simple_segtree",
    "{",
    "    int _n;",
    "    int size;",
    "    std::vector<S> d;",
    "    simple_segtree() : simple_segtree(0) {}",
    "    explicit simple_segtree(int n) { init(n); }",
    "    explicit simple_segtree(const std::vector<S> &v)",
    "    {",
    "        _n = (int)v.size();",
    "        size = 1;",
    "        while (size < _n) size <<= 1;",
    "        d.assign(2 * size, e());",
    "        for (int i = 0; i < _n; ++i) d[size + i] = v[i];",
    "        for (int i = size - 1; i >= 1; --i) d[i] = op(d[2*i], d[2*i+1]);",
    "    }",
    "",
    "    void init(int n)",
    "    {",
    "        _n = n;",
    "        size = 1;",
    "        while (size < _n) size <<= 1;",
    "        d.assign(2 * size, e());",
    "    }",
    "",
    "    void set(int p, S x)",
    "    {",
    "        assert(0 <= p && p < _n);",
    "        int pos = size + p;",
    "        d[pos] = x;",
    "        pos >>= 1;",
    "        while (pos >= 1)",
    "        {",
    "            d[pos] = op(d[2*pos], d[2*pos+1]);",
    "            pos >>= 1;",
    "        }",
    "    }",
    "",
    "    S get(int p)",
    "    {",
    "        assert(0 <= p && p < _n);",
    "        return d[size + p];",
    "    }",
    "",
    "    // prod on [l, r)",
    "    S prod(int l, int r)",
    "    {",
    "        assert(0 <= l && l <= r && r <= _n);",
    "        if (l == r) return e();",
    "        l += size; r += size;",
    "        S sml = e(), smr = e();",
    "        while (l < r)",
    "        {",
    "            if (l & 1) sml = op(sml, d[l++]);",
    "            if (r & 1) smr = op(d[--r], smr);",
    "            l >>= 1; r >>= 1;",
    "        }",
    "        return op(sml, smr);",
    "    }",
    "",
    "    // apply range [l, r) with mapping(f, s) done as point-wise updates (O(range * (log n))!)",
    "    void apply(int l, int r, F f)",
    "    {",
    "        assert(0 <= l && l <= r && r <= _n);",
    "        if (l == r) return;",
    "        for (int i = l; i < r; ++i)",
    "        {",
    "            S cur = get(i);",
    "            S nxt = mapping(f, cur);",
    "            set(i, nxt);",
    "        }",
    "    }",
    "",
    "    template <bool (*g)(S)>",
    "    int max_right(int l)",
    "    {",
    "        return max_right(l, [](S x){ return g(x); });",
    "    }",
    "",
    "    template <class G>",
    "    int max_right(int l, G g)",
    "    {",
    "        assert(0 <= l && l <= _n);",
    "        assert(g(e()));",
    "        if (l == _n) return _n;",
    "        int idx = l + size;",
    "        S sm = e();",
    "        do",
    "        {",
    "            while ((idx & 1) == 0) idx >>= 1;",
    "            if (!g(op(sm, d[idx])))",
    "            {",
    "                while (idx < size)",
    "                {",
    "                    idx <<= 1;",
    "                    if (g(op(sm, d[idx])))",
    "                    {",
    "                        sm = op(sm, d[idx]);",
    "                        ++idx;",
    "                    }",
    "                }",
    "                return idx - size;",
    "            }",
    "            sm = op(sm, d[idx]);",
    "            ++idx;",
    "        } while ((idx & -idx) != idx);",
    "        return _n;",
    "    }",
    "",
    "    template <bool (*g)(S)>",
    "    int min_left(int r)",
    "    {",
    "        return min_left(r, [](S x){ return g(x); });",
    "    }",
    "",
    "    template <class G>",
    "    int min_left(int r, G g)",
    "    {",
    "        assert(0 <= r && r <= _n);",
    "        assert(g(e()));",
    "        if (r == 0) return 0;",
    "        int idx = r + size;",
    "        S sm = e();",
    "        do",
    "        {",
    "            --idx;",
    "            while (idx > 1 && (idx & 1))",
    "                idx >>= 1;",
    "            if (!g(op(d[idx], sm)))",
    "            {",
    "                while (idx < size)",
    "                {",
    "                    idx = idx * 2 + 1;",
    "                    if (g(op(d[idx], sm)))",
    "                    {",
    "                        sm = op(d[idx], sm);",
    "                        --idx;",
    "                    }",
    "                }",
    "                return idx + 1 - size;",
    "            }",
    "            sm = op(d[idx], sm);",
    "        } while ((idx & -idx) != idx);",
    "        return 0;",
    "    }",
    "};",
    "",
    "//* 0 based indexing ",
    "//* [l,r)",
    "//* int max_right(int l, G g) - max r s.t g(l...r-1) is true and g(l...r) is false; true for e()",
    "//* int min_left(int r, G g) - min l s.t g(l...r-1) is true and g(l-1....r-1) is false; true for e()",
    "//* monoid - op is associative and e() is identity",
    ""
  ],
  "description": "template_simple_segtree"
},

    "template_heavy_light": {
  "prefix": "template_heavy_light",
  "body": [
    "template <class S,",
    "          auto op,",
    "          auto e,",
    "          class F,",
    "          auto mapping,",
    "          auto composition,",
    "          auto id,",
    "          const bool islazy,",
    "          const bool on_edge>",
    "class heavy_light_chan",
    "{",
    "    /*",
    "        info:",
    "            - 0 indexed",
    "            - range [pos[u], out[u]) represents subtree of u",
    "        vars:",
    "            - r = tree root",
    "            - heavy[u] = heavy child v (edge (u,v) is heavy edge) ",
    "            - root[u] = It is the starting point of the heavy chain (for u-v it is u, if v is heavy and u is not heavy). ",
    "            - on_edge = true => values on edges. Internally, value of edge is stored at lower node (node more away from root)",
    "        warning:",
    "            - handle segtree initialization correctly",
    "    */",
    "    using lazy_t = lazy_segtree<S, op, e, F, mapping, composition, id>;",
    "    using simple_t = simple_segtree<S, op, e, F, mapping>;",
    "    using seg_t = std::conditional_t<islazy, lazy_t, simple_t>;",
    "",
    "public:",
    "    int n, r;",
    "    vector<int> par, heavy, dep, root, pos, out;",
    "    seg_t seg;",
    "    heavy_light_chan(int n, vector<vector<int>> adj, int r = 0) : ",
    "    n(n), r(r), par(n, -1), heavy(n, -1), dep(n), root(n), pos(n), out(n), ",
    "    seg(n) ",
    "    {   ",
    "        assert(r < n);",
    "        auto dfs_sz = [&](int u, auto &&dfs) -> int",
    "        {",
    "            //* ensure that in adj list first child is the heavy child",
    "            int sz = 1, mx_sz = 0; ",
    "            for(auto &v : adj[u])",
    "            {",
    "                if(v != par[u])",
    "                {",
    "                    par[v] = u, dep[v] = dep[u] + 1;",
    "                    int s = dfs(v, dfs);",
    "                    sz += s;",
    "                    if(s > mx_sz)",
    "                    heavy[u] = v, mx_sz = s, swap(adj[u][0], v); ",
    "                }",
    "            }",
    "            return sz;",
    "        };",
    "        int timer = 0;",
    "        auto dfs_hld = [&](int u, auto &&dfs) -> void",
    "        {",
    "            pos[u] = timer++;",
    "            for(auto v : adj[u])",
    "            {",
    "                if(v != par[u])",
    "                {",
    "                    root[v] = (heavy[u] == v ? root[u] : v);",
    "                    dfs(v, dfs);",
    "                }",
    "            }",
    "            out[u] = timer ; // exclusive",
    "        };",
    "        par[r] = -1;",
    "        dep[r] = 0;",
    "        root[r] = r;",
    "        dfs_sz(r, dfs_sz);",
    "        dfs_hld(r, dfs_hld);",
    "    }",
    "    int lca(int u, int v)",
    "    {",
    "        for (; root[u] != root[v]; v = par[root[v]])",
    "        {",
    "            if (dep[root[u]] > dep[root[v]])",
    "            {",
    "                swap(u, v);",
    "            }",
    "        }",
    "        return (dep[u] < dep[v] ? u : v);",
    "    }",
    "",
    "    // *process_path [u, v] in O(logn * logn)",
    "    template <typename O>",
    "    void process_path(int u, int v, O oper)",
    "    {",
    "        for (; root[u] != root[v]; v = par[root[v]])",
    "        {",
    "            if (dep[root[u]] > dep[root[v]])",
    "                swap(u, v);",
    "            oper(pos[root[v]], pos[v]);",
    "        }",
    "        if (dep[u] > dep[v])",
    "            swap(u, v);",
    "        ",
    "        if(!on_edge)",
    "            oper(pos[u], pos[v]);",
    "        else if(u != v)",
    "            oper(pos[u] + 1, pos[v]);",
    "    }",
    "",
    "    void set(int v, const S &value) ",
    "    {",
    "        seg.set(pos[v], value);",
    "    }",
    "    ",
    "    S get(int v) ",
    "    {",
    "        return seg.get(pos[v]);",
    "    }",
    "",
    "    void modify_path(int u, int v, const F &f) ",
    "    {",
    "        process_path(u, v, [this, &f](int l, int r) ",
    "        {",
    "            seg.apply(l, r + 1, f); // convert inclusive [l,r] -> atcoder apply [l, r+1)",
    "        });",
    "    }",
    "",
    "    S query_path(int u, int v) ",
    "    {",
    "        S res = e();",
    "        process_path(u, v, [this, &res](int l, int r) ",
    "        {",
    "            S part = seg.prod(l, r + 1);",
    "            res = op(res, part);",
    "        });",
    "        return res;",
    "    }",
    "",
    "    void modify_subtree(int u, const F &f) ",
    "    {",
    "        if (!on_edge) ",
    "        {",
    "            seg.apply(pos[u], out[u], f); // subtree = [pos[u], out[u])",
    "        } ",
    "        else ",
    "        {",
    "            // edges stored at children; exclude its parent values that it at u",
    "            if (pos[u] < out[u] - 1)",
    "                seg.apply(pos[u] + 1, out[u], f);",
    "        }",
    "    }",
    "    S query_subtree(int u) ",
    "    {",
    "        if (on_edge) ",
    "        {",
    "            if (pos[u] < out[u] - 1)",
    "            {",
    "                return seg.prod(pos[u] + 1, out[u]);",
    "            }",
    "            else",
    "            {",
    "                return e();",
    "            }",
    "        }",
    "        return seg.prod(pos[u], out[u]);",
    "    }",
    "",
    "};",
    ""
  ],
  "description": "template_heavy_light"
},
"template_crt": {
  "prefix": "template_crt",
  "body": [
    "// Extended Euclidean Algorithm",
    "int extended_gcd(int a, int b, int &x, int &y) ",
    "{",
    "    if (b == 0) { x = 1; y = 0; return a; }",
    "    int x1, y1;",
    "    int g = extended_gcd(b, a % b, x1, y1);",
    "    x = y1;",
    "    y = x1 - (a / b) * y1;",
    "    return g;",
    "}",
    "",
    "// Modular inverse using extended Euclid",
    "int modinv(int a, int m) ",
    "{",
    "    int x, y;",
    "    int g = extended_gcd(a, m, x, y);",
    "    if (g != 1) return -1; // Inverse doesn't exist",
    "    return (x % m + m) % m;",
    "}",
    "",
    "// Chinese Remainder Theorem solver",
    "int crt(vector<int> &a,  vector<int> &m) ",
    "{",
    "    int M = 1;",
    "    for (int mi : m) M *= mi;",
    "",
    "    int result = 0;",
    "    for (int i = 0; i < a.size(); ++i) {",
    "        int Mi = M / m[i];",
    "        int inv = modinv(Mi, m[i]);",
    "        result = (result + a[i] * Mi % M * inv % M) % M;",
    "    }",
    "",
    "    return (result % M + M) % M; // Ensure positive",
    "}",
    ""
  ],
  "description": "template_crt"
},
"template_lazy_segtree": {
  "prefix": "template_lazy_segtree",
  "body": [
		"template <class S,",
		"          auto op,",
		"          auto e,",
		"          class F,",
		"          auto mapping,",
		"          auto composition,",
		"          auto id>",
		"struct lazy_segtree",
		"{",
		"public:",
		"    unsigned int bit_ceil(unsigned int n)",
		"    {",
		"        unsigned int x = 1;",
		"        while (x < (unsigned int)(n))",
		"            x *= 2;",
		"        return x;",
		"    }",
		"    int countr_zero(unsigned int n)",
		"    {",
		"        return __builtin_ctz(n);",
		"    }",
		"    lazy_segtree() : lazy_segtree(0) {}",
		"    explicit lazy_segtree(int n) : lazy_segtree(std::vector<S>(n, e())) {}",
		"    explicit lazy_segtree(const std::vector<S> &v) : _n((int)(v.size()))",
		"    {",
		"        size = (int)bit_ceil((unsigned int)(_n));",
		"        log = countr_zero((unsigned int)size);",
		"        d = std::vector<S>(2 * size, e());",
		"        lz = std::vector<F>(size, id());",
		"        for (int i = 0; i < _n; i++)",
		"            d[size + i] = v[i];",
		"        for (int i = size - 1; i >= 1; i--)",
		"        {",
		"            update(i);",
		"        }",
		"    }",
		"",
		"    void set(int p, S x)",
		"    {",
		"        assert(0 <= p && p < _n);",
		"        p += size;",
		"        for (int i = log; i >= 1; i--)",
		"            push(p >> i);",
		"        d[p] = x;",
		"        for (int i = 1; i <= log; i++)",
		"            update(p >> i);",
		"    }",
		"",
		"    S get(int p)",
		"    {",
		"        assert(0 <= p && p < _n);",
		"        p += size;",
		"        for (int i = log; i >= 1; i--)",
		"            push(p >> i);",
		"        return d[p];",
		"    }",
		"",
		"    S prod(int l, int r)",
		"    {",
		"        assert(0 <= l && l <= r && r <= _n);",
		"        if (l == r)",
		"            return e();",
		"",
		"        l += size;",
		"        r += size;",
		"",
		"        for (int i = log; i >= 1; i--)",
		"        {",
		"            if (((l >> i) << i) != l)",
		"                push(l >> i);",
		"            if (((r >> i) << i) != r)",
		"                push((r - 1) >> i);",
		"        }",
		"",
		"        S sml = e(), smr = e();",
		"        while (l < r)",
		"        {",
		"            if (l & 1)",
		"                sml = op(sml, d[l++]);",
		"            if (r & 1)",
		"                smr = op(d[--r], smr);",
		"            l >>= 1;",
		"            r >>= 1;",
		"        }",
		"",
		"        return op(sml, smr);",
		"    }",
		"",
		"    S all_prod() { return d[1]; }",
		"",
		"    void apply(int p, F f)",
		"    {",
		"        assert(0 <= p && p < _n);",
		"        p += size;",
		"        for (int i = log; i >= 1; i--)",
		"            push(p >> i);",
		"        d[p] = mapping(f, d[p]);",
		"        for (int i = 1; i <= log; i++)",
		"            update(p >> i);",
		"    }",
		"    void apply(int l, int r, F f)",
		"    {",
		"        assert(0 <= l && l <= r && r <= _n);",
		"        if (l == r)",
		"            return;",
		"",
		"        l += size;",
		"        r += size;",
		"",
		"        for (int i = log; i >= 1; i--)",
		"        {",
		"            if (((l >> i) << i) != l)",
		"                push(l >> i);",
		"            if (((r >> i) << i) != r)",
		"                push((r - 1) >> i);",
		"        }",
		"",
		"        {",
		"            int l2 = l, r2 = r;",
		"            while (l < r)",
		"            {",
		"                if (l & 1)",
		"                    all_apply(l++, f);",
		"                if (r & 1)",
		"                    all_apply(--r, f);",
		"                l >>= 1;",
		"                r >>= 1;",
		"            }",
		"            l = l2;",
		"            r = r2;",
		"        }",
		"",
		"        for (int i = 1; i <= log; i++)",
		"        {",
		"            if (((l >> i) << i) != l)",
		"                update(l >> i);",
		"            if (((r >> i) << i) != r)",
		"                update((r - 1) >> i);",
		"        }",
		"    }",
		"",
		"    template <bool (*g)(S)>",
		"    int max_right(int l)",
		"    {",
		"        return max_right(l, [](S x)",
		"                         { return g(x); });",
		"    }",
		"    template <class G>",
		"    int max_right(int l, G g)",
		"    {",
		"        assert(0 <= l && l <= _n);",
		"        assert(g(e()));",
		"        if (l == _n)",
		"            return _n;",
		"        l += size;",
		"        for (int i = log; i >= 1; i--)",
		"            push(l >> i);",
		"        S sm = e();",
		"        do",
		"        {",
		"            while (l % 2 == 0)",
		"                l >>= 1;",
		"            if (!g(op(sm, d[l])))",
		"            {",
		"                while (l < size)",
		"                {",
		"                    push(l);",
		"                    l = (2 * l);",
		"                    if (g(op(sm, d[l])))",
		"                    {",
		"                        sm = op(sm, d[l]);",
		"                        l++;",
		"                    }",
		"                }",
		"                return l - size;",
		"            }",
		"            sm = op(sm, d[l]);",
		"            l++;",
		"        } while ((l & -l) != l);",
		"        return _n;",
		"    }",
		"",
		"    template <bool (*g)(S)>",
		"    int min_left(int r)",
		"    {",
		"        return min_left(r, [](S x)",
		"                        { return g(x); });",
		"    }",
		"    template <class G>",
		"    int min_left(int r, G g)",
		"    {",
		"        assert(0 <= r && r <= _n);",
		"        assert(g(e()));",
		"        if (r == 0)",
		"            return 0;",
		"        r += size;",
		"        for (int i = log; i >= 1; i--)",
		"            push((r - 1) >> i);",
		"        S sm = e();",
		"        do",
		"        {",
		"            r--;",
		"            while (r > 1 && (r % 2))",
		"                r >>= 1;",
		"            if (!g(op(d[r], sm)))",
		"            {",
		"                while (r < size)",
		"                {",
		"                    push(r);",
		"                    r = (2 * r + 1);",
		"                    if (g(op(d[r], sm)))",
		"                    {",
		"                        sm = op(d[r], sm);",
		"                        r--;",
		"                    }",
		"                }",
		"                return r + 1 - size;",
		"            }",
		"            sm = op(d[r], sm);",
		"        } while ((r & -r) != r);",
		"        return 0;",
		"    }",
		"",
		"private:",
		"    int _n, size, log;",
		"    std::vector<S> d;",
		"    std::vector<F> lz;",
		"",
		"    void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
		"    void all_apply(int k, F f)",
		"    {",
		"        d[k] = mapping(f, d[k]);",
		"        if (k < size)",
		"            lz[k] = composition(f, lz[k]);",
		"    }",
		"    void push(int k)",
		"    {",
		"        all_apply(2 * k, lz[k]);",
		"        all_apply(2 * k + 1, lz[k]);",
		"        lz[k] = id();",
		"    }",
		"};",
		"/*",
		"    !index is 0 based [l,r)",
		"",
		"    S - segment tree node",
		"    op(left, right) - monoid merge of two S values ",
		"    e() - identity element for op",
		"    F - lazy tag type",
		"    mapping - apply a tag f to a node value s",
		"    composition - combine two tags (f applied after g)",
		"    id - neutral tag (no-op)",
		"",
		"    void set(int p, S x) - ar[p] = x",
		"    S get(int p) - return ar[p]",
		"",
		"    S prod(int l, int r) - Combine values in [l, r) via op.",
		"    S all_prod() == prod for whole array",
		"",
		"    void apply(int p, F f) - Apply tag f only to index p.",
		"    void apply(int l, int r, F f) - Apply tag f to every index in [l, r).",
		"",
		"    int max_right(int l, G g) - max r s.t g(l...r-1) is true and g(l...r) is false; true for e()",
		"    int min_left(int r, G g) - min l s.t g(l...r-1) is true and g(l-1....r-1) is false; true for e()",
		"",
		"",
		"",
		"    struct S { int sum, size; };",
		"    S op(S left, S right) { return {left.sum + right.sum, left.size + right.size}; }",
		"    S e() { return {0, 0}; }",
		"    struct F { int x; bool is_set; }; // lazy tag type",
		"    S mapping(F f, S s)  // apply tag f to segment s",
		"    {",
		"        if (!f.is_set) return s;",
		"        return {f.x * s.size, s.size};",
		"    }",
		"    ",
		"    F composition(F f, F g) { // Compose two tags: new f after old g",
		"        if (f.is_set) return f;",
		"        return g;",
		"    }",
		"    F id() { return {0, false}; }",
		"",
		"    * constructor - expects vector<S> ",
		"",
		"*/"
	],
	"description": "template_lazy_segtree"
	}

}